{"pages":[{"title":"关于我","text":"你好，这里是一枚在读硕士生，作为刚入门的菜鸟，在读paper的阶段头秃中……在努力学习技术的同时，也对很多其他领域感兴趣，摄影📹 / 音乐剧🎵 / 设计🎨 / 电影🎬 / 文学📖。希望可以成为理性与情感并重，严谨与浪漫共存的人。 Education Background Master &nbsp;&nbsp;computer science and technologyEast China Normal University &nbsp;&nbsp;2019 - 2022 Lab: &nbsp;&nbsp;Digital Media &amp; Computer Vision Lab Advisor: &nbsp;&nbsp;Lizhuang Ma, Haichuan Song Research Field point cloud Bachelor computer science and technologyEast China Normal University 2015 - 2019 Internship NVIDIA Shanghai applied architecture tool teamSoftware engineer 2018.12 ~ 2019.10 Interested in… Computer vision Deep Learning C++ Web 联系我 在blog留言 QQ: 707767931 Wechat: Angericky Email: jingjingbudlet@gmail.com / presente_de_deus@163.com 涉足无人抵达的远方就能摘取星星上的金子。","link":"/about/index.html"},{"title":"设计集collection","text":"大学时期制作的海报找不太到了，放上追星途上为爱发电的一些拙劣之作，也算是纪念年少青春的闲暇时光～这辈子的水平大概也就止于对优秀的平面设计作品欣赏啦。 ![手幅1](/images/collection/1.jpg) ![手幅2](/images/collection/2.jpg) ![手幅3](/images/collection/3.jpg) ![手幅4](/images/collection/4.jpg) ![透扇2](/images/collection/5.png) ![透扇3](/images/collection/6.jpg) ![透卡1](/images/collection/7.png) ![透卡1-1](/images/collection/7-1.jpg) ![透卡1-2](/images/collection/7-2.jpg) ![透卡1-3](/images/collection/7-3.jpg) ![透卡2](/images/collection/8.png) ![公告2](/images/collection/9.jpg)","link":"/collection/index.html"}],"posts":[{"title":"A-CNN点云的环形卷积神经网络论文笔记","text":"《A-CNN：Annularly Convolutional Neural Networks on Point Clouds》，针对点云的ACNN环状卷积神经网络的论文笔记。 ACNN 《A-CNN：Annularly Convolutional Neural Networks on Point Clouds》 CVPR 2019Artem Komarichev et. al Wayne State Universitypaper地址：http://www.cs.wayne.edu/zzhong/papers/A-CNN_CVPR2019.pdf 简介提出了用regular和dilated两种环形卷积，应用到已有的层级神经网络。能够在信号处理级别适应几何多样性和可扩展性。应用到了object classification，part segmentation，和semantic segmentation的大规模场景，并在一系列标准benchmark数据集上得到了SOTA（部分SOTA）。 解决问题PointNet++中用了MSG方法做grouping分组，利用不同尺度的球去采样点云，这样的采样有重叠的。再对提出的采样方式进行卷积，变成全局特征，Pointnet的特征提取层不能很好地编码点云结构。 贡献点提出了点云数据上的环卷积(annular convolution)，能够在每个局部环形区域定义任意kernel size，能帮助捕获3D形状更好的几何表达。并且对扩张环(dilated rings)提出了新的多级层次方法，有利于闭环卷积和pooling。 思想PointNet++的多尺度区域可能会有交叠（同样的邻域点可能会被重复包括在不同规模的区域里），导致计算结构的性能下降（为什么这样会导致性能下降？重叠点的信息被包括在不同尺度，造成信息冗余，限制网络学习更重要的特征）。而本文工作更明智地提取了多尺度的邻域点特征，环结构在查询点的邻域没有交叠区域。 常规和扩张环Regular ring是密集的不同尺寸的圆环，而Dilate ring在环与环之间有一定的空隙，隔一个环、空一圈地去采样。常规环可以看成是空隙为0的扩张环。优点： 1. kNN查找可以限制搜索区域保证没有交叠 2. 同样的kernel size，环卷积有更大的感受野，而卷积参数量不变。 3. 用最大池化之后，环结构能集合更多重要的特征。 （2维的Dilated Convolution的最大价值是可以不做pooling损失信息，也不改变feature map的大小而增大感受野。而之前的FCN使用pooling下采样来增大感受野，但随后又不得不通过Deconvolution或者upsampling来增大feature map大小，这样的一小一大总会损失很多信息。） 有限制的KNN查找PointNet++的ball query算法找的是中心点周围一个半径为R的查询球里的前K个邻居，不能保证最近的点都被找到了（为什么）。用Rinner和Router能保证搜索范围里找到的是最近的独一无二的点集。 邻域排序分为投影和排序两个步骤。投影：投影点集到查询点qi的法向平面上。用投影是因为点乘对于排序点有限制。排序：利用点乘和叉乘把邻域点按照顺时针或者逆时针方向排序。 环卷积和池化环卷积的优势： 环形卷积对局部区域有置换不变性。 无论顺时针逆时针排序，得到的结果都一样，避免了大规模场景数据集的点云法线方向翻转问题 能够用任意的kernel size，而不只是1x1的kernel 网络结构模型的具体结构如上图，下采样部分基本上就是一直使用Annular Convolution去编码局部点云，最终变成一个全局的特征。encoder结构中的第一层环卷积用regular ring，第二层环卷积用dilated ring。对同一个询问点的不同环进行并行处理。在解码器部分，该网络并没有模仿PointNet++的FP结构，而是借鉴了PU-Net中的decoder结构，即将不同尺度的点云插值到原始尺度，然后拼接后通过MLP得到分割结果。网络的参数如下：Classification中，用了[[0.0, 0.1],[0.1, 0.2]]的regular ring和[[0.1, 0.2], [0.3, 0.4]]的dilated ring。Segmentation中，用了[[0.0, 0.1],[0.1, 0.2]]的regular ring和[[0.1, 0.2], [0.3, 0.4]]和[[0.2，0.4],[0.6, 0.8]]的dilated ring。 数据集standard benchmark dataset:： ModelNet10, ModelNet40, ShapeNet-part, S3DIS, ScanNet 结果1. Classification在ModelNet40数据集上比Point2Sequence差一点点。(VRN Ensemble网络结构的性能最好) 2. Segmentation ShapeNet-part数据集上，evaluation用了两种不同的输入：没有normals作为附加特征和有normals作为附加特征的。前者性能比Point Grid（volumetric方法）和Point CNN差一点，后者达到了SOTA（但是比without normals的PointGrid差）。 S3DIS数据集上用了六折交叉验证。比Point CNN效果稍微差一点，PointCNN用了有padding的non-overlapping block采样策略。 在ScanNet数据集上达到了最好的分割效果。 3. Ablation experiment结果","link":"/2019/10/27/A-CNN论文笔记/"},{"title":"C++开发学习计划","text":"这一年，领悟到无论是出国/保研/考研/就业的道路，我们都应该拓宽横向比较的世界，不局限在身边的人，要去看更多优秀的人是怎么做的，这种借鉴能让我避免处在井底之蛙的境地，对信息搜集和个人成长都大有益处。时光无法补救，已经蹉跎到大四了，既然意识到积累太少，就更应该补上专业方面的知识，将书读薄再读厚。 前言即将踏入2019年实习阶段。在面试了几次才知道自己有多菜，但每一次面试都会发现自己的不足，可以有针对性地查漏补缺，因此有面试经历真是很棒。 发现如果早点开始做就业准备，一定可以拿到比较喜欢的offer，而我的大三大四就不会显得这么被动，以至于往读研方向发展没有退路。 成绩好就是学习好的认识太狭隘了。说课业紧张而不去实习，其实是自我管理和学习效率不够，时间是海绵里的水，挤挤总是有的。 这一年，领悟到无论是保研还是就业的道路，我都应该拓宽横向比较的世界，不局限在身边的人，要去看更多优秀的人是怎么做的，这种借鉴能让我避免处在井底之蛙的境地，对信息搜集和个人成长都大有益处。 时光无法补救，已经蹉跎到大四了，既然意识到积累太少，就更应该补上专业方面的知识，将书读薄再读厚。 需要读的书/掌握的知识C++ Effective C++ More Effective C++ STL源码解析 对象模型 C++ Primer Plus C++ Primer 操作系统 操作系统概论 现代计算机操作系统（这本书是讲操作系统的 深入理解计算机操作系统（这本书是讲程序在操作系统中处理的） 计算机网络 计算机网络第六版谢仁希 tcp/ip详解 数据结构 哈希表实现，冲突解决方法 AVL树、红黑树 哈夫曼编码 算法 常用排序算法、复杂度计算、查找、DFS、BFS 记忆化搜索、DP 最短路算法 字符串相关的(如：KMP、BM等）。 线段树 编译原理 DFA、NFA 解决二义性的方法 解决移进/规约冲突 设计模式 大话设计模式 设计模式解析第二版 每个设计模式做小demo并备份 暂时就列这些，利用上班通勤和其他碎片时间慢慢读～","link":"/2018/12/26/C-开发学习计划/"},{"title":"PU-GAN论文笔记","text":"《PU-GAN: a Point Cloud Upsampling Adversarial Network》 ICCV 2019 的论文笔记。 PU-GAN 《PU-GAN: a Point Cloud Upsampling Adversarial Network》 ICCV 2019paper地址 https://arxiv.org/pdf/1907.10844.pdf)源码地址 https://github.com/liruihui/PU-GAN) 简介PU-GAN是第一篇将GAN用到点云上采样的工作。提出了一个对抗网络，能够训练一个从潜在空间产生多类别点分布的生成网络，还有一个根据潜在空间的点分布去隐式评估生成点集的监督网络。 贡献点问题：如何成功训练一个能平衡生成器和监督器，并且避免收敛性差的GAN框架？解决方法： 提出了up-down-up expansion单元，在扩展点特征的时候能生成更多种点分布，增强feature expansion能力。 提出一个self-attention单元，增强聚集特征的质量， 设计了一个综合loss，涵盖了adversarial loss（用了ICCV 2017提出的港大least-squared loss）、uniform loss（让生成点均匀分布，PU-Net的Loss忽略了局部点混乱，PU-GAN的uniform loss同时考虑到了局部分布均匀性和全局分布均匀性）、reconstruction loss（限制生成点在目标表面），让监督器能学到更多潜在空间模式。 思想网络结构 Generator部分：分成特征提取、特征扩展、点集生成三部分。特征扩展部分里为了生成更多种点分布，用了Up-down-up扩展单元。点集生成部分用了最远采样法去保留特征扩展里最有意义的rN个点，所以F_{up}里生成(r+2)N。Up-down-up单元中，先上采样点特征，再把它下采样回去，计算F1和F2的差异，得到\\triangle，将\\triangle上采样得到\\triangle_{up}，拼接F_{up}'特征，即为最终输出。 UP-feature：为了增加拷贝特征多样性做上采样，用到FoldingNet里的方法，去对每个feature-map生成独特的2D拷贝，能够让新生成的点离开输入点一定距离；然后用了self-attention单元，以及一系列MLP。Down-feature：用了一系列MLP回归点特征。 Discriminator部分：增加了self-attention单元，相比于基本的MLP，提高了特征整合的效果，同时提高了后续特征提取的能力。Self-attention单元用了ICML 2019 SAGAN的self-attention方法。将输入点用几个MLP转换到特征集合G和H，根据G和H生成注意力权重W。用另一个MLP生成特征集合K，与W相乘W^TK，再加上输入特征得到输出特征。 Loss设计值得注意的是Uniform Loss，比PU-Net中多考虑了局部分布均匀性。 L_{uni} = \\Sigma_{j=1}^M U_{imbalance} \\cdot U_{clutter}U_{imbalance}评估全局均匀点分布，S是通过ball query裁剪的近邻点子集，期望上采样后得到的点数是\\hat{n}。 U_{clutter}评估局部均匀点分布，点j是S_j中的任意一点，d_{j,k}是该点与它第k个近邻的距离，\\hat{d}是期望距离。 不足对于非常有挑战性的案例，比如骆驼的脚，输入的噪声和稀疏点不能恢复成原形状。","link":"/2019/11/25/PU-GAN论文笔记/"},{"title":"EJS里判断一个变量是否可用","text":"改博客时候遇到的问题：ejs互相传参数，怎么得知参数有没有被传呢？ 问题描述node代码里存在两种情况：12res.render(&apos;home/content&apos;, { detail:detail,list:list } );res.render(&apos;home/content&apos;, { detail:detail } ); EJS:123&lt;% if(list==undefined){ %&gt; &lt;span&gt;暂时没有内容&lt;/span&gt;&lt;% } %&gt; 当node里不提供list的时候，页面判断list是否存在的时候报错12345678ReferenceError: D:\\demo\\views\\home\\content.ejs:10 8| &lt;/div&gt; 9| &lt;/div&gt;&gt;&gt; 10| &lt;% 11| if(list==undefined){ 12| 13| }list is not defined 这时候怎么办？难道必须在node里添加一个list为空的变量过来吗？还是有在EJS里有其他验证方法？ 解决方法123if(locals.list==undefined){ ...} 用到EJS的locals就可以防止报错啦～","link":"/2019/01/12/EJS里判断一个变量是否可用/"},{"title":"KPConv论文笔记","text":"《KPConv: Flexible and Deformable Convolution for Point Clouds》的论文笔记。 《KPConv: Flexible and Deformable Convolution for Point Clouds》 ICCV 2019Author: Hugues Thomas, Charles R. Qi et.al.From: Mines ParisTech, Facebook AI Research, Stanford Universitypaper地址:点击这里源码地址：https://github.com/HuguesTHOMAS/KPConv KPConv == Kernel Point Convolution) 简介这是PointNet作者作为二作的一篇文章，超过了当前的SOTA七八个点。 提出了新的卷积方式： 用输入特征、关联算式附加在卷积核点上作为卷积核权重。 可以用不定个数的卷积核点进行训练，因此很灵活。 KPConv能比较快速地训练很深的网络结构。 刚性卷积在简单任务（物体分类或者小场景分割数据集）上表现更好，可变形卷积在复杂任务（大场景分割数据集）上表现更好。 KPConv在数量少的kernel points上显示了鲁棒性。 可变形kernel能更好地拟合场景对象。 贡献点是第一个提出空间可变形点卷积的工作。先前用MLP做点卷积的方法让卷积运算变复杂，导致网络收敛比较困难。而本文定义了一个能够直接学习权重的显式卷积核，不需要用MLP做中间表达。 思想rigid kernel points的位置作者先通过求解优化来放置不同数量的Kernel Points，希望K个Kernel Points在球面上离得足够远，又离球心不要太远。限制其中一点为中心点，每个点对其他点有一定的斥力。球心对其他点有一定的引力。最终，周围的点被限制在平均半径1.5σ内，以确保每个Kernel Points之间的影响有小幅度的重叠。（\\sigma是kernel points的影响距离，由输入密度决定，\\sigma_j = \\sum \\times dl_j） 总结一下核心点卷积的大概思路： 以点x为球心确定一个球体； 内确定若干个核心点，每个核心点带一个权重矩阵； 在球体范围内的任意点，用核函数，计算出该点的权重矩阵，用该矩阵对这个点的feature进行变换； 在球体内的每个点，都用上一步的方法，得出一个新的feature，最后将feature累加起来，作为点x的feature。 用优化求出的K个kernel点位置：有足够多K覆盖g的球形区域的时候，刚性kernel尤其有效。 Deformable Kernel Point Convolution借鉴了微软亚研ICCV 2017的《Deformable convolutional networks》的思想。 如果kernel points的位置不是固定的而是学习到的，表达能力会更强。（？作者考虑到对每个卷积层学习一个全局的kernel points集合，但是这种不会比固定位置的kernel points更有表达力。）因此提出可变形卷积，让网络对每个卷积层的所有点位置学习一个有K个局部位移向量的集合，去适应点云结构。 直接引入deformable效果并不好，因此还对可变形卷积加了两个正则化损失项： 引入一个拟合正则化损失，让任何一个kernel point和最近的输入点距离不能太大。 对覆盖区域重复的kernel points加了一个排斥正则化项，令kernel points彼此之间的距离不能太小。 Kernel Point Network Layers为了保证点采样位置的空间一致性，用网格下采样方法进行下采样。选择每一层的支撑点作为原始输入点云的中心，让这些点携带特征位置。 Pooling layer每层pooing都加倍cell的大小，每个新位置的池化用最大池化或者KPConv实现。KPConv的池化被叫做strided KPConv，类似于二维图像的strided convolution（是为了去除冗余信息，取代pooling层。pooling可以看作2x2的核以步长为2进行跨步）。 KPConv layer强制邻域有n_(max)维，多余的shadow neighbors在计算时被忽略。 网络参数kernel point影响度量设为：\\sigma_j = \\sum \\times dl_j .对于第j层网络，单元大小为dl_j。对于刚性kernel，卷积半径是2.5\\sigma_j，平均kernel point半径是是1.5\\sigma_j。对于可变形kernel，卷积半径为r_j = \\rho \\times dl_j。对于所有的实验，K = 15， \\sum = 1.0， \\rho = 5.0。 dl_0$$由输入的数据集大小决定，降采样$$dl_(j+1) = 2 * dl_j 网络设计分类网络 KP-CNN：有五层网络，每层都有两个卷积block，除了第一层都用一个KPConv加一个strided KPConv（用pool而非neighbors，这样就类比于2维图像里的strided conv？）。最后通过一个全局平均池化，一个全连接层，一个softmax层进行分类。可变形卷积只对最后5个KPConv block用可变形卷积。 分割网络 KP-FCNN：用skip links传递中间层特征，用最近邻上采样策略去得到最终的点向特征。将特征与上采样结果级联，再用一元卷积进行处理。 实验结果 简单任务（分类+部件分割） 复杂任务（真实场景分割）","link":"/2019/11/18/KPConv论文笔记/"},{"title":"O(n)算法查找第k大的数","text":"面试中常见的经典算法题：O(n)算法查找第k大的数。 O(n)算法查找第k大的数思路这里讲利用快速排序Partion的算法，核心思想是快排的分支算法，具体思路： 利用快排的partion函数将数组分成左右两个部分 如果位置p刚好等于k，则说明p位置的数，就是我们要找的数，如果分出来的边界位置p小于给定的数k，我们知道最小的第k个数，肯定在p的右边，如果p大于给定的k则在p边界的左边 递归在p的左边或者右边查找 注：p为数组下标需要加1。 具体的细节可以查看《算法导论》第九章，下面是简单的实现代码。 复杂度对于快速排序，算法复杂度是O(N * logN)。而这个算法的算法复杂度是O(N)。为什么呢？其实这个地方的算法复杂度分析很有意思。 第一次交换，算法复杂度为O(N)，接下来的过程和快速排序不同，快速排序是要继续处理两边的数据，再合并，合并操作的算法复杂度是O(1)，于是总的算法复杂度是O(N * logN)（可以这么理解，每次交换用了N，一共logN次）。 但是这里在确定枢纽元的相对位置（在K的左边或者右边）之后不用再对剩下的一半进行处理。也就是说第二次插入的算法复杂度不再是O(N)而是O(N/2)。？接下来的过程是1+1/2+1/4+…….. &lt; 2，换句话说就是一共是O(2N)的算法复杂度也就是O(N)的算法复杂度。 代码递归实现123456789101112131415161718192021class Solution {public: int partion(vector&lt;int&gt; &amp;nums,int k,int start, int end){ int tmp = nums[start], n = nums.size(), left = start, right = end; while(left &lt; right){ while(right &gt; left &amp;&amp; nums[right] &lt; tmp) right --; if(right &gt; left) nums[left ++] = nums[right]; while(left &lt; right &amp;&amp; nums[left] &gt;= tmp) left ++; if(left &lt; right) nums[right --] = nums[left]; } nums[left] = tmp; if(left == k - 1) return tmp; else if(left &gt; k - 1) return partion(nums, k, start, left - 1); else return partion(nums, k, left + 1, end); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { return partion(nums, k, 0, nums.size() - 1); }}; 非递归实现12345678910111213141516171819202122232425262728293031static auto sycn_false = [](){ ios :: sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int start = 0, end = nums.size() - 1; while(start &lt;= end){ int tmp = nums[start], left = start, right = end; while(left &lt; right){ while(left &lt; right &amp;&amp; nums[right] &lt; tmp) right --; if(left &lt; right){ nums[left ++] = nums[right]; } while(left &lt; right &amp;&amp; nums[left] &gt;= tmp) left ++; if(left &lt; right){ nums[right --] = nums[left]; } } nums[left] = tmp; if(left == k - 1) return nums[left]; else if(left &gt; k - 1) end = left - 1; else start = left + 1; } return -1; }};","link":"/2018/12/26/O-n-算法查找第k大的数/"},{"title":"Vue学习总结","text":"xmind + 笔记，整理细碎的知识点。 Vue.js是什么Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。需要理解的是，Vue的一个核心思想是数据驱动，组件与组件之间只有数据交换。对于视图的修改，不会直接操作DOM，而是通过修改数据。交互复杂时，只关心数据修改会让代码逻辑变得很清晰，不用碰触DOM，这样的代码非常利于维护。 Vue知识体系这是我自己根据官方文档在思维导图上构建的知识体系。 生命周期什么是生命周期 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册js方法，可以让我们用自己注册的js方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。 生命周期图及标注 特别值得注意的是created钩子函数和mounted钩子函数的区别 生命周期钩子函数beforeCreate 在实例初始化后，数据观测(data observer)和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下配置：数据观测(data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的render函数首次被调用。 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。 beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vuex是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。","link":"/2019/03/10/Vue学习总结/"},{"title":"gitlab与github","text":"两者都是用git实现代码托管的版本仓库，两者很相似，那它们的区别是？ 简介相比于GitHub，GitLab更适合企业级使用，为企业搭建GitLab软件版本管理服务器。 GitLab：https://about.gitlab.com/GitHub: https://github.com/ GitLab利用Ruby on Rail开发的开源应用程序，实现一个自托管的Git项目仓库，可以通过web界面进行访问公开的或者私人项目。Ruby on Rail是一个使你开发、部署、维护web应用程序变得简单的框架。GitLab拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释，可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库，它提供一个代码片段功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub。 两者区别相同点二者都是基于web的Git仓库，在很大程度上GitLab是仿造GitHub来做的，他们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。 不同点： GitHub如果使用私有仓库，是需要付费的，GitLab可以在上面搭建私人的免费仓库 GitLab让开发团队对他们的代码仓库拥有更多的控制，相对于GitHub，它有不少的特色： 允许免费设置仓库权限 允许用户选择分享一个project的部分代码 允许用户设置project的获取权限，进一步提升安全性 可以设置获取到团队整体的改进进度 通过innersourcing让不在权限范围内的人访问不到该资源 gitlab安装及使用： 关闭防火墙和selinux，并安装安装依赖的包 12345systemctl stop firewalld &amp;&amp; systemctl disable firewalldsetenforce 0 并修改/etc/selinux/config yum -y install openssh-server postfix yum install -y curl policycoreutils-python openssh-server 启动positfix和sshd 12systemctl enable postfix &amp;&amp; systemctl start postfixsystemctl enable sshd &amp;&amp; systemctl start sshd 下载安装包并安装安装包 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash 打开/etc/gitlab/gitlab.rb,将external_url = 'http://git.example.com'修改为自己的IP地址：http://xxx.xx.xxx.xx,然后执行下面的命令，对GitLab进行编译。 sudo gitlab-ctl reconfigure 登录GitLab Username: root Password: 5iveL!fe GitLab管理 gitlab-ctl start/stop/restart/reconfigure git相关概念： git 是一种版本控制系统，是一个命令，是一种工具 gitlib 是基于git功能的开发库 github 是一个基于git实现在线代码托管的仓库，包含一个网站界面，向互联网开放 gitlab 是一个基于git实现的在线代码仓库托管软件，一般用于在企业内搭建git私服git-ce是社区版，gitlab-ee是企业版，收费版","link":"/2019/02/22/gitlab与github/"},{"title":"git修改已提交的备注","text":"用rebase修改github上历史修改的备注。 最后一次提交的注释1git commit --amend 然后在出来的编辑界面，直接编辑注释的信息,保存退出。 更早之前的历史修改假设要修改当前版本往前三次版本的状态,四次就把HEAD~3改成HEAD~4,以此类推/1git rebase -i HEAD~3 假设要从第一个版本开始修改，1git rebase -i --root 然后会看到，123pick sha1 Xpick sha1 Ypick sha1 Z 要修改哪个,就把那行的pick改成edit，123pick sha1 Xedit sha1 Ypick sha1 Z :wq保存并退出。通过git log查看历史，可以发现git的最后一次提交已经变成刚才选的那个了然后就和修改最后一次提交一样了1git commit -amend 修改完了之后,这样返回1git rebase --continue 这时候就又回到正常状态了 压缩掉不需要的版本和上面一个修改历史差不多，也是使用git rebase同样会看到123pick sha1 Xpick sha1 Ypick sha1 Z 不同的是要压缩掉哪个版本,就把那个版本pick改成squash123pick sha1 Xsquash sha1 Ypick sha1 Z 保存退出,会出现备注,再次保存退出。用git log查看那个备注为Y的版本已经没了。","link":"/2019/01/02/git修改已提交的备注/"},{"title":"Google Girl Hackathon 2019赛后感","text":"很幸运拿到了Dream Company这次girl hackathon的门票。在周五到周末三天的小组团队项目比赛里，我们组DeliveryGo拿到了Best Team Top 2，很开心～2019年，分别到了我最喜欢的软件和硬件公司体验了一下，非常幸运。 Google Shanghai的地理位置也太好了吧，居然在环球金融中心，左拥金茂大厦，右抱东方明珠。不过陆家嘴上下班时间有点挤。Google Shanghai的食堂还不错，是自助餐式的，如果天天在这里吃这种健康的食物，我一定会变瘦的。周末给我们订的外卖也不错，准备的零食也很充分，抹茶糯米团真好吃。 HR小哥哥Brett的酒窝好甜哦！呜呜呜，过去social发现是校友，真好。逛了一圈office，发现工位没有我们NVIDIA的大（骄傲脸）。（对不起，主题跑偏了） 这次girl hackathon的项目里，我和本系学妹以及浙大的三个姑娘组成了一个五人团队，根据题目起的队名叫DeliveryGo（模仿alphaGo），另外几个妹子主要看算法，只有我懂一点JS，所以只好挑起做前端的大梁啦。 我主要做了web的路径规划可视化，已经放到我github的repository里了，UI挺好看的，也感谢队友们一起设计、找图和PS的努力。 48小时里写出来这样的demo，我发现自己的学习速度超乎预期，没想到能写这么快，看来在NV实习的一个月的成长还是挺快的，不仅是关于前端的知识，还有自学的能力。我对自己更有信心了。 从算法结果、Demo、pre三方面打分，最后我们拿到了Best team top 2。是很棒的结果，谢谢队友们的共同努力，前一天通宵的努力是有收获的。 没拿到Best team top one，挺可惜的，可能是因为操作失误，我们组的算法结果交错了几组，没拿到最好的performance and efficiency。Presentation展示Demo的时候，也有其他组做了的UI很好。有点难过，这种不甘心大概也能更好地驱动我继续学习，努力向前走吧。 谢谢nowcoder以及Google提供的这次机会，我是一个容易被鼓励但会很轻易怀疑自己的人，这个活动对我的激励真的很大。 (顺带一提，google奖品里给的包真的很不错，这个安卓机器人模型也很可爱！) 有点后遗症，由于长时间盯着电脑，肩膀和脖子不舒服了两三天，做这行还是要多健身多运动呀～","link":"/2019/03/18/google-girl-hackthon-2019赛后感/"},{"title":"Hello World","text":"This is jingjing’s very first post. There is some information about hexo. Welcome to Hexo! This is jingjing’s very first post.Hello world~Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/12/22/hello-world/"},{"title":"网页的跳转页面及参数传递方法","text":"两者都是用git实现代码托管的版本仓库，两者很相似，那它们的区别是？ 跳转页面 直接在跳转的内容外部加上 html加参数onclick=”function()”function里写window.open(&quot;url&quot;, _self/__blank(default);或者 12window.location.href=&quot;url&quot;;window.history.back(-1); 参数传递： url传参：第一个页面(a.html)： 1234var obj = a.value; //传给弹出页面参数var url = &apos;jxb.html?obj=&apos;+obj;url = encodeURI(url);window.open(url, &quot;&quot;, &quot;width=600,height=400&quot;); 第二个页面(b.html)： 1234var url = decodeURI(window.location.href);var argsIndex = url .split(&quot;?obj=&quot;);var arg = argsIndex[1]; 注:中文传输:可以在页面a用encodeURI 编码url 在b页面用decodeURI解码url cookie传参(不能跨域)： 1234567function setCookie(cname,cvalue){ document.cookie = cname + &quot;=&quot; + cvalue;}function getCookie(cname){ var name = cname + &quot;=&quot;; var ca = document.cookie;}` localStorage对象传参： 1234567a.html：var div = doucment.getElementById(&apos;要获取字符串的DIV ID名&apos;);localStorage.string = div.textContent;b.html：var div = doucment.getElementById(&apos;要写入的DIV ID名&apos;);div.textContent = localStorage.string; window.opener() 父页面： 12&lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot;/&gt;window.open(&quot;子页面.html&quot;); 子页面： 1window.opener.document.getElementByIdx(&apos;textfield&apos;).value=&apos;123123123&apos;; 如果跨域，子页面还要加上document.domain=”父页面url”","link":"/2019/03/05/html跳转页面的参数传递/"},{"title":"深度学习在3D点云处理中的探索【笔记】","text":"bilibili上刘永成博士的分享课的笔记记录。 Introduction multi-view images + 2D CNN2D CNN对多视角图像进行学习和信息综合，恢复3D shape缺点：拍摄自遮挡，3D信息损失 volumetric data + 3D CNNCAD model进行3D Grid的划分缺点：grid划分太粗，形状信息损失；划分太精细，复杂度非常高 mesh data（网格数据） + DL(GNN)? ——刚起步的阶段，需要探究 深度图 + CNN point cloud + DL（GNN &amp; CNN）？ point cloudraw sensor data 直接可以得到 (激光雷达)simple representation(N*(x, y, z, color, normal))better 3D shape capturing 应用领域：自动驾驶、AR&amp;VR、机器人、遥感图像、3D人脸&amp;医学、3D游戏动画的形状设计、e.g. 目前需要思考的问题：如何更有效、更快速地处理点云？不规则点云怎么做深度学习/神经网络（进行研究） datasets:简单的model: Princeton ModelNet: 1k个点 ShapeNet Part: 2k个点 PartNet models: (CVPR 2019)(数据集刚提出来，考虑精度提高) 层次化语义分割标注，coarse -&gt; fine-grained 面向使用的复杂的model: Stanford 3D indoor scene: 8k个点 Semantic 3D: 4 billion in total ScanNet（室内场景）: seg + det检测 自动驾驶类：KITTI, nuScenes: det检测 挑战和难点： 不规则，无序。输入顺序不同，卷积结果会发生变化。需要建立置换排列不变性 刚性变换的鲁棒性(robustness to rigid transformations)：naive的toy点云 对于点云的corruption, outlier noise的鲁棒性; partial data局部数据；large-scale data保持高效 Brief reviewpointnet家族共享多层感知机(Shared MLP) + max pool（内部数据发生置换，结果不会发生改变）逐级映射到高层表示刚体变换（包括平移、旋转、反转）: 增加T-net(transform net)， 将输入的三维点云进行变形，得到规范的数据，能够映射到高维卷积神经网络：由局部到全局的学习范式PointNet++ 捕捉局部模式显式地模仿CNN输入点云采样一些点，以这些点作为中心，寻找局部邻域 规整化处理 分成3D grid，对每个grid做PointNet + 3D CNN（VoxelNet, CVPR 2018） lattice映射到晶格网络+bilateral convolution双边卷积+hash index（SPLATNet, CVPR 2018） 原始点云映射到体积空间，没有任何离散或者近似（PCNN, SIGGRAPH 2018） 直接学习，卡方矩阵学习变换(PointCNN, NIPS 2018)加权和置换，simultaneously weight and permute the input features 方向编码+尺度敏感(PointSIFT, CVPR 2018)对每一个领域，找邻居点，建立坐标系八个象限，进行方向卷积（orientation-encoding）参考深度学习的思想，concat多层特征，端到端找到最合适的尺度(scale-aware) (Self-Organizing Map)自组织映射+MLP( SO-Net, CVPR 2018)在空间里用Self-organizing点，拟合了geometry structure，学习后能够capture到映射，用了Kd-Tree Pointwise CNN(CVPR 2018)简单暴力，直接用3x3的网格，求和+归一化，当作一个特征去卷积 (一篇比较早的文章，影响比较大，比较独树一帜) Kd-Net, ICCV 2017用Kd-Tree对原始点云做划分，通过变换的学习到达根节点。将数据结构用到点云分割里。 FCPN, ECCV 2018模仿2D空间的FCN，用3D grid, 用pointnet学习每个grid的low-level特征，再用3D CNN做分割可以一次性处理200k个点 graph-based modeling DGCNN, TOG 2019提出边缘卷积EdgeConv，不卷积点，卷积点与点之间的边用邻居点和特征差进行权重学习，得到卷积结果 Regularized GCNN. MM 2018图卷积 用拉普拉斯矩阵 正则化，kNN思想 GAN for Point Cloud. ICLR 2019用point cloud的格式做gan需要学习图结构 Spectral Graph Convolution. ECCV 2018在谱域进行学习spectral graph conv谱聚类 + recursive spectral cluster pooling Superpoint Graph, CVPR 2018minimal partition(最优化的解决方案) + GCN（边缘条件卷积）用邻边建立superpoint graph作者在CVPR 2019提出了Oversegmentation做superpoint graph Deep GCNs. ICCV 2019探究能不能把graph的网络做深残差结构、膨胀卷积是否有用 convolution kernel 卷积有效性 KC-Net. CVPR 2018用点云配准的学习思想增加kernel correlation（核相关） KPConv. arXiv 2019用了一个带权重的点集kernel points类比2D kernel，输入点云和kernel points里面的每一个点的权重矩阵相乘，然后通过一个相关系数加权求和。 MCCNN. TOG 2018蒙特卡洛卷积。使用蒙特卡洛公式离散化（引进密度） PointConv. CVPR 2019 Geo-CNN. CVPR 2019引入角度，更好地学习局部几何","link":"/2019/09/17/【笔记】深度学习在3D点云处理中的探索/"},{"title":"vue-router传递参数params和query的区别","text":"如题。 比较用法1. 用法query要用path来引入，params要用name来引入(当你使用params方法传参的时候，要在路由后面加参数名)，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。如果传参时未定义name，则获取不到params。 路由界面1234567&lt;router-link :to=\"{ name: 'router1', path: 'Hello', params: { id: 'menuIndex' }, query: { id: 'menuIndex' } }\"&gt;&lt;button&gt;Go to Foo&lt;/button&gt;&lt;/router-link&gt; 2. url地址显示query更加类似于我们ajax中get传参，params则类似于post，说得简单一些，即前者在浏览器地址栏中显示参数，后者则不显示。 queryhttp://localhost:8080/workorder/newApply?type=BOX_DEPLOY&amp;typeDesc=%E5%B0%8F%E7%99%BD%E7%9B%92%E9%83%A8%E7%BD%B2 paramshttp://localhost:8080/workorder/newApply 3. 注意点query刷新不会丢失query里面的数据params刷新会丢失params里面的数据","link":"/2019/03/03/vue-router传递参数params和query的区别/"},{"title":"常用快捷键和指令","text":"包括但不限于vim和Linux命令。 网页开发者工具 打开/关闭chrome + safari mac: opt + command + i win: F12 ctrl + shift + i/j 截屏快捷键 mac: command + shift + 3，全屏自动保存到桌面 command + shift + 4，鼠标框选需要截图的地方，自动保存到桌面 space键可以移动这个区域 shift键可以锁定x/y轴进行拖动 option键能按照区域圆心进行放大 win: Win + Shift+ S， 截图自动保存到剪贴板 Vim12345678910111213141516171819202122232425262728293031ctrl + f # 屏幕『向下』移动一页ctrl + b # 屏幕『向上』移动一页n + [space](n为数字，space空格键) # 按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20[space] 则光标会向后面移动 20 个字符距离。0 # 这是数字『 0 』：移动到这一行的最前面字符处$ # 移动到这一行的最后面字符处G # 移动到这个档案的最后一行nG # n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行n + [Enter] # n 为数字。光标向下移动 n 行dd # 删除游标所在的那一整行ndd # n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行yy # 复制游标所在的那一行nyy # n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行set nu # 设置显示行号set nonu # 设置不显示行号ctrl + z #最小化fg # 恢复最小化 Linux命令 df 显示磁盘统计空间12345678df -h文件系统 容量 已用 可用 已用% 挂载点/dev/vda1 40G 5.3G 32G 15% /devtmpfs 909M 0 909M 0% /devtmpfs 920M 0 920M 0% /dev/shmtmpfs 920M 444K 919M 1% /runtmpfs 920M 0 920M 0% /sys/fs/cgrouptmpfs 184M 0 184M 0% /run/user/0 du 显示当前目录下文件夹大小du -h —maxdepth=11234567891011232K ./scripts55M ./src12K ./distribute13M ./lib952K ./CMakeFiles19M ./install176K ./cmake4.0K ./test580K ./docs2.7M ./tools5.8M ./python free 于显示内存状态1234free -mtotal used free shared buff/cache availableMem: 1838 265 981 0 591 1395Swap: 2047 0 20 查看linux ip地址 ip addr show | grep inet | awk ‘{ print $2; }’ | sed ‘s/\\/.*$//‘ find命令查找最近修改过的文件 按时间查找也有参数 -atime 访问时间 -ctime 改变状态的时间 -mtime修改的时间。但要注意，这里的时间是以24小时为单位的。查看man手册后使用，你会很迷惑： -mtime n： Files data was last modified n*24 hours ago. 字面上的理解是最后一次修改发生在n个24小时以前的文件，但实际上 12find ./ -mtime 0：返回最近24小时内修改过的文件。find ./ -mtime 1 ： 返回的是前48~24小时修改过的文件。而不是48小时以内修改过的文件。 那怎么返回10天内修改过的文件？find还可以支持表达式关系运算，所以可以把最近几天的数据一天天的加起来： ./ -mtime 0 -o -mtime 1 -o -mtime 2 ……```123456789 另外， -mmin参数-cmin / - amin也是类似的。# win打开我的电脑 Win + E# vscode - 打开terminal ```ctrl+`","link":"/2019/02/22/常用快捷键/"},{"title":"任意多边形窗口的线段裁剪算法","text":"计算机图形学的作业。对凸多边形窗口的线段裁剪Cyrus-Beck算法进行了拓展. 思路多边形窗口如果是凹多边形，补全为凸多边形窗口组。用每个凸多边形窗口对输入线段进行裁剪，最后线段相减得到结果。 程序流程图 具体实现利用OpenGL函数库和C++实现了任意多边形窗口的线段裁剪算法。代码开发环境MacOS + Xcode。 自定义数据结构类Polygon多边形，有两个成员变量Point2D数组，分别存储多边形的顶点以及法向量，还有一个成员变量_num存储边的数量。结构中的ComputeNormals()函数计算出内法向量。 123456789struct Polygon{ int _num; //Num of lines, not points Point2D* points; Point2D* norms; void Set(vector&lt;Point2D&gt; p){}; // 根据输入点数组存储和计算Polygon中的成员变量 void ComputeNormals(){};} 主要函数ComuteLineCross()， 用来找到凹点。输入多边形的点数组p（p的首元素是x坐标值最大的点，依次按边顺序的点数组），并返回凹点在数组中的索引。 12345678910111213141516171819202122int ComputeLineCross(vector&lt;Point2D&gt; p) { int _num = p.size(); Point2D A = p[_num - 1], B = p[0], C = p[1]; float cross = (B._x - A._x) * (C._y - A._y) - (B._y - A._y) * (C._x - A._x); bool flag = cross &lt; 0; // 根据凸点叉乘值的正负作为凹点的评判标准 for(int i = 1; i &lt; _num; ++i) { int pre = i - 1 ; // 点的前一个相邻点索引 int next = i == _num - 1? 0 : i + 1; // 点的后一个相邻点索引 A = p[pre]; B = p[i]; C = p[next]; // 对多边形每个点的相邻边向量进行叉乘 cross = (B._x - A._x) * (C._y - A._y) - (B._y - A._y) * (C._x - A._x); if((cross &lt; 0)!= flag) // 如果该点的叉乘值与凸点值正负不同，则该点是凹点，输出凹点索引 return i; } return -1;} 主要函数generateConvexPolygons()，用来生成补全的凸多边形组。 123456789101112131415161718192021void generateConvexPolygons(vector&lt;Point2D&gt; points, vector&lt;vector&lt;Point2D&gt;&gt;&amp; convexPolygons){ int _num = points.size(); int i = ComputeLineCross(points); if(i == -1) // 根据函数返回值判断输入多边形是凸多边形还是凹多边形 cout &lt;&lt; \"The polygen is a concave polygen.\" &lt;&lt; endl; else cout &lt;&lt; \"The polygen is a convex polygen.\" &lt;&lt; endl; while(i != -1) // i不为-1时是凹点索引，循环查找原多边形里的凹点 { int pre = i - 1 &lt; 0 ? _num - 1 : i -1; int next = i + 1 &lt; _num ? i + 1 : 0; vector&lt;Point2D&gt; p{points[pre], points[i], points[next]}; convexPolygons.push_back(p); // 生成一个新的补全凸多边形 points.erase(points.begin() + i); // 在原多边形里删除该凹点 _num --; i = ComputeLineCross(points); } convexPolygons.push_back(points);} 主要函数Cyrus_Beck()，用每个凸多边形窗口对原线段进行剪裁。输入需要剪裁的一条线段、一个多边形以及有效线段数组，返回值为-1时代表该线段在多边形外侧，无有效线段，无需剪裁。 12345678910111213141516171819202122232425262728293031323334int Cyrus_Beck(Line2D&amp; src, Polygon&amp; poly){ float tin = 0.0f, tout = 1.0f; Point2D&amp;&amp; vec = src.GetVector(); for(int i = 0; i &lt; poly._num; ++i) { Line2D&amp;&amp; line = poly.GetLine(i); Point2D&amp;&amp; norm = poly.GetNormal(i); // 计算出法向量 float nc = vec * norm; // 得到内法向量与线段向量的点积 if(nc == 0) continue; // 点在边上 else { float hit = (line._start - src._start) * norm / nc; // 计算交点的参数t if(nc &gt; 0) tout = min(tout, hit); else tin = max(tin, hit); } } if(tin &lt;= tout) { Line2D dest_T; dest_T._start = src._start + vec * tin; dest_T._end = src._start + vec * tout; dest_V.push_back(dest_T); // 加入每个凸多边形裁剪的线段数组 } return tin &gt; tout;} 实验结果程序运行后，先用鼠标左键选取一系列的点，单击鼠标右键完成多边形的构建。接下来用鼠标左键选取线段的起点和终点进行裁剪。 图1 凸多边形窗口裁剪线段结果 图2 凹多边形窗口裁剪线段结果","link":"/2019/11/12/任意多边形窗口的线段裁剪算法/"},{"title":"扔鸡蛋问题","text":"Leetcode 887 Super Egg Drop. DP问题 题目描述：你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例1: 输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例2: 输入：K = 2, N = 6输出：3 示例3: 输入：K = 3, N = 14输出：4 提示: 1 &lt;= K &lt;= 100 1 &lt;= N &lt;= 10000 解决思路：这个题目乍一看能暴力解决，然而仔细想想就会发现是需要用dp才能求出最优解的。 问题f(N)，表示1～N层。假设有两个鸡蛋，从F层往下扔，会出现两种情况： 碎了，F - 1次， 没碎，还有N - F层，可以试两个鸡蛋，转化为子问题f(N - F) 推广之后，用f(K, N), K表示鸡蛋的个数，N表示楼层有N层。 当第一个鸡蛋从第F层扔下的时候，会得到两种结果： 如果碎了，还剩K - 1个鸡蛋，有F - 1层楼层需要扔，问题转化成f(K - 1, F - 1) 如果没碎，还剩K个鸡蛋，有N - F个楼层需要扔， 问题转化成f(K , N - F) 可得状态转移方程f(K, N) = min( 1 + max( f(K - 1, F - 1), f(K, N - F) ) ) 推出代码：123456789101112131415161718192021const int MAXK = 100, MAXN = 100;int max(int a, int b) {return a &gt; b ? a : b;}int min(int a, int b) {return a &lt; b ? a : b;}int superEggDrop(int K, int N) { int dp[MAXN+2][MAXK+2]; for (int i = 0; i &lt;= MAXN; i++) { dp[i][0] = 0; dp[i][1] = i; } for (int j = 2; j &lt;= MAXK; j++) { for (int i = 1; i &lt;= MAXN; i++) { dp[i][j] = i; for (int k = 1; k &lt; i; k++) { dp[i][j] = min(dp[i][j], max(dp[k-1][j-1], dp[i-k][j]) + 1); } } } return dp[N][K];} 用这个办法做出来TLE，怎么办呢？我们可以改变一下求解的思路，求k个鸡蛋在m步内可以测出多少层。 f(K, M)，表示K个鸡蛋在M步内，最坏条件下能测出的层数。假设一共有K个鸡蛋，最多能扔N层。从F层扔下鸡蛋，会出现两种情况： 碎了，剩下K - 1个鸡蛋和M - 1步，f(K - 1, M - 1) 没碎，剩下K个鸡蛋和M - 1步，f(K, M - 1)因此f(K, M) = f(K - 1, M - 1)(摔碎时能确定的层数) + f(K, M - 1)（没摔碎时能确定的层数） + 1（本层）考虑边界情况： 没有鸡蛋，一层都测不出来。可得f(K, 0) = 0 只有一个鸡蛋，那必须从第1层开始扔，最坏情况要扔到M层才能测出来，一共扔M次。可得f(1, M) = M 推出代码：12345678910111213141516class Solution {public: int superEggDrop(int K, int N) { if(K == 1) return N; int dp[10001][101] = {0}; for(int m = 1; m &lt;= N; m ++){ for(int k = 1; k &lt;= K; k ++){ dp[m][k] = dp[m - 1][k] + dp[m - 1][k - 1] + 1; if(dp[m][k] &gt;= N) return m; } } return N; }};","link":"/2019/05/08/扔鸡蛋问题/"},{"title":"华东师范大学优秀毕业生答辩稿","text":"2019.4.8，优秀毕业生答辩稿。 &emsp;&emsp;亲爱的老师、同学们，我是来自计算机系的学生赵菁菁。&emsp;&emsp;今天想和大家分享一下我作为一名计算机的学生，在华师大三年半以来的学习经历。首先按惯例是做个简单的自我介绍。 &emsp;&emsp;目前是大四学生，大学完成度90%，保研到本校马利庄老师的多媒体和计算机视觉实验室，同时也在NVIDIA半导体科技公司做开发实习生。 &emsp;&emsp;我兴趣广泛，什么都喜欢尝试一下。所以这四年我的生长脉络是一颗自由生长的乱点技能点的树。&emsp;&emsp;前两年做过一些Web相关的项目，JS MySQL PHP Python什么语言都用过。&emsp;&emsp;出于对设计的兴趣也很好奇计算机视觉的研究，和朋友折腾了一个基于yolov3框架的目标检测项目，对应用在cv领域的深度学习有了初步了解&emsp;&emsp;平时在维护、改进个人博客和我的github（期待拥有一面绿墙），阅读技术分享和其他大学的计算机在线课程。业余时间会去看音乐剧、唱唱歌或者做点美工。 &emsp;&emsp;我的学生工作经历里，就业创业服务工作室是很重要的一段。在这里我结识了不同专业的同学和老师，学到了做一件事就追求做到最好的精神，大家为着同一个目标充满热情地设计、安排活动、联系嘉宾，讨论可行方案，努力改进每一次活动。&emsp;&emsp;任职期间，我参与组织过年度毕业生大型秋季招聘会、精英训练营、华师创业说品牌活动、挑战杯活动等。我和上届下届的部门伙伴现在也是很好的朋友，经常聚餐。&emsp;&emsp;除此之外，在团学联文艺部和科创团委，我点亮了美工设计的技能点；在合唱团，我向艺术特长生学习，提升了视唱水平和艺术修养，参加各种电视台的演出；社会实践部分，我们小团队走访了不少IT相关的公司，给大一新生们做了一份有趣的职业指南手册。 &emsp;&emsp;描述我的本科生涯，一半是“做什么都是因为喜欢”，另一半是“弱水三千，我愿只取一瓢”。&emsp;&emsp;命运指使我读计算机专业，可能是它给我这辈子安排的最棒的事。&emsp;&emsp;大学前两年的我对专业不抱有太大的热情，只是觉得数据结构和算法还挺有意思的，但即使编程实践第一次考试就拿了优，也因为觉得自己基础不好，畏头畏尾没参加ACM队的选拔。&emsp;&emsp;结果后来真香定律愈演愈烈。我发现随着知识积累，对现象的思考和观察事物的层次也会渐渐不一样。 &emsp;&emsp;学习的过程中有过自我质疑，甚至痛苦，但回想这四年，即使为了大作业或者项目熬夜通宵，也还是很快乐，我的发际线也可以再拼一下。 &emsp;&emsp;我剖析了一下自己喜欢计算机的理由。&emsp;&emsp;我喜欢数学和逻辑思维，并且痴迷于解决实际生活的问题，喜欢严谨和抽象化的思维方式。我乐于源源不断扩充并学习新的技术，也喜欢程序员自黑的幽默感。 &emsp;&emsp;在学习开发和人工智能的过程中，我越来越觉得以前认为的枯燥的计算机体系结构、高性能计算、分布式架构等越来越有趣。这些底层知识不会过时，而且它们就像力学之于建筑的地位，牢牢地撑起顶端枝叶的快速生长。不懂的话，干活是能干，但设计的时候可能想不到一些潜在的问题，而给以后带来无穷无尽的麻烦。所以我最近在业余时间也在回顾和巩固这些领域的内容。&emsp;&emsp;我相信花时间去学习新的知识，新的技能，都不会浪费时间，可能就在某天某个机遇下，就会发现自己学过看起来无用的东西，有用。 &emsp;&emsp;很荣幸今天大家坐在下面，听我絮絮叨叨讲了这么多自己学习的经历，谢谢大家。","link":"/2019/04/08/华东师范大学优秀毕业生答辩稿/"},{"title":"用Supervisor管理进程、监控程序","text":"Supervisor是一个很棒的进程管理工具，能够监听进程重新启动，不需写脚本进行控制。 简介Supervisor(http://supervisord.org)是一个用Python写的进程管理client/server系统工具，能够让用户检测和控制UNIX型操作系统上进程，支持Linux、Mac OS X，windows上不能使用。它能够用来方便地监听、重启、启动、关闭一个或者多个进程。当用supervisor管理的一个进程意外被kill，supervisor能够监听到进程杀死，会自动将它重启，做到自动恢复的功能，不需写shell脚本进行控制。 安装方式Ubuntu上：apt-get install supervisorCentos上：yum install supervisor用这些基于源的方式安装，supervisor的版本可能会比较老。推荐使用基于python的安装方式：easy_install supervisor或者是基于pip的安装方式：pip install supervisor 配置直接输入echo_supervisord_conf命令能够将默认配置项输出到terminal。但一般需要重定向到一个配置文件中：echo_supervisord_conf &gt; /etc/supervisord.conf如果没有root权限，可以重定向到自定义路径的配置文件：echo_supervisord_conf &gt; [directory]/[yourconf] 管理配置文件安装完成后，用户通过编写配置文件来满足自己的需求，这些配置都可以写到supervisord.conf里。如果应用程序很多，最好通过include的方式把不同程序（组）写到不同的配置文件里。12[include]files = /etc/supervisor/*.conf 需要改动的配置信息有这些：12345678910111213[program:server] ;写你的程序名字directory = /home/xxx ; 程序的启动目录command = sh run.sh ; 启动命令，与命令行启动的命令是一样的autostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = xxx ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /etc/supervisord.d/log/confd.log ;日志统一放在log目录下 启动supervisor启动进程：supervisord -c [directory]/[yourconf]（通过 -c 选项指定配置文件路径，如果不指定会按照以下路径查找配置文件：$CWD/supervisord.conf, $CWD/etc/supervisord.conf, /etc/supervisord.conf）通过命令行查看supervisord是否在运行：ps aux | grep supervisord设置开机启动以及systemd方式启动1234sudo chmod +x /etc/rc.d/init.d/supervisordsudo chkconfig --add supervisordsudo chkconfig supervisord onsudo service supervisord start 控制命令Supervisord有两个可用的命令行 supervisord（server端，之前用到了） supervisorctl（client端，是supervisord的命令行客户端工具，用来在控制supervisord） supervisorctl supervisorctl stop myprogram，停止某一个进程(myprogram)，myprogram为 [program:xxx] 里配置的进程名称。 supervisorctl start myprogram，启动某个进程。 supervisorctl restart myprogram，重启某个进程。 supervisorctl status，查看进程状态。 supervisorctl stop groupworker ，重启所有属于名为 groupworker 这个分组的进程(start,restart 同理)。 supervisorctl stop all，停止全部进程，注：start、restart、stop 都不会载入最新的配置文件。 supervisorctl reload，载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。 supervisorctl update，根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启。 e.g.12$ supervisorctl statusserver RUNNING pid 19985, uptime 0:00:05 直接输入supervisorctl会进入shell交互界面。12$ supervisorctlsupervisor&gt; supervisordsupervisord用来初始启动supervisord，启动、管理配置中设置的进程。1234567891011121314151617181920212223242526272829$ supervisord --helpsupervisord -- run a set of applications as daemons.Usage: /usr/bin/supervisord [options]Options:-c/--configuration FILENAME -- configuration file-n/--nodaemon -- run in the foreground (same as 'nodaemon true' in config file)-h/--help -- print this usage message and exit-v/--version -- print supervisord version number and exit-u/--user USER -- run supervisord as this user (or numeric uid)-m/--umask UMASK -- use this umask for daemon subprocess (default is 022)-d/--directory DIRECTORY -- directory to chdir to when daemonized-l/--logfile FILENAME -- use FILENAME as logfile path-y/--logfile_maxbytes BYTES -- use BYTES to limit the max size of logfile-z/--logfile_backups NUM -- number of backups to keep when max bytes reached-e/--loglevel LEVEL -- use LEVEL as log level (debug,info,warn,error,critical)-j/--pidfile FILENAME -- write a pid file for the daemon process to FILENAME-i/--identifier STR -- identifier used for this instance of supervisord-q/--childlogdir DIRECTORY -- the log directory for child process logs-k/--nocleanup -- prevent the process from performing cleanup (removal of old automatic child log files) at startup.-a/--minfds NUM -- the minimum number of file descriptors for start success-t/--strip_ansi -- strip ansi escape codes from process output--minprocs NUM -- the minimum number of processes available for start success--profile_options OPTIONS -- run supervisord under profiler and output results based on OPTIONS, which is a comma-sep'd list of 'cumulative', 'calls', and/or 'callers', e.g. 'cumulative,callers') Supervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。1supervisorctl -c /etc/supervisord.conf","link":"/2019/04/29/用Supervisor管理进程、监控程序/"},{"title":"PU-Net点云上采样网络论文笔记","text":"《PU-Net: Point Cloud Upsampling Network》的论文笔记。 PU-Net 《PU-Net: Point Cloud Upsampling Network》 CVPR 2018Lequan Yu. et.al The Chinese University of Hong Kong点击论文地址开源代码：https://github.com/yulequan/PU-Net 简介根据PointNet++和PointSetGeneration衍生而来。通过多分支卷积单元去学习逐点的多级特征和扩大点集，在patch-level通过共同损失函数，在潜在的曲层表面均匀分布地上采样点。采样更均匀，位置离底层表面更近。 解决问题如何上采样到能更完整地表达潜在曲面的密集点云，类似于二维中的图像超分辨率问题。而在点云数据的挑战是：1. 点云没有空间顺序和规则结构 2. 生成的点云应该位于目标物体的表面来表示几何目标对象 3. 生成的点应当有信息量，而不是杂乱无章生成的点云数据分布应当更加均匀，因此简单的插值方法并不适用。 贡献点提出了一个深度点云上采样网络，目标是从一组稀疏的点中生成一组更密集、更均匀的点。该网络在小块级别使用多级特征聚合方式进行训练，从而捕获局部和全局信息。网络设计通过对包含非局部几何图形的单个特征进行操作来允许上下文感知的上采样，从而绕过了对点之间指定顺序的需求。根据分布均匀和距离偏差建立了衡量指标，实验证明了方法的有效性。 该方法作为第一次对上采样使用深度网络的尝试，仍然有许多局限性，不能填补大的漏洞和缺失的部分。此外，该网络无法为采样严重不足的微小结构添加有意义的点。 核心思想学习每个点的多粒度（局部和全局）特征，再在特征空间种扩大点集，左后将扩大的点集映射回三维。 网络设计 网络结构分为四块：小块提取Patch Extraction、点特征嵌入Point Feature Embedding、特征扩展Feature Expansion和坐标重建Coordinate Reconstruction。首先，从给定的一组先前的3D模型种提取不同规模和分布的点补丁。然后，点特征嵌入通过层次特征学习和多级特征聚集，将原始3D坐标映射到特征空间。之后扩展特征的个数，并且通过一系列全连接层重建输出点云的3D坐标。 Patch Extraction为了让网络从对象中学习局部几何图形，本工作用基于小块（patch）的方法训练网络和学习几何语义。因此我们先收集一组有各种各样形状的3D对象作为先验信息，随机选择这些物体表面的M个点，然后指定一个测地距d，将每个中心点的d范围内的所有点作为一个patch，然后用泊松分布在每个中心点上随机采样N_hat个点，将采样点作为ground truth。用不同大小的d形成不同尺度、不同密度的patch。 Point Feature Embedding同时采用了层次特征学习Hierarchical feature learning和多级特征聚合Multi-level feature aggregation两种特征学习策略。如图所示，先用PointNet++里的Hierarchical feature learning方法捕捉到不同尺度的特征，但是这里为了保留更多局部细节特征，采取比较小的grouping分组半径。然后用Multi-level feature aggregation集合特征。一些先前工作用了skip-connections的结构去做多级特征聚合，而本文发现该结构对于自顶向下的广播不是很高效。在根据网络中的低层更能反映小规模局部特征，本文提出了让网络学习不同层次的特征重要性，以此结合为最终特征的方法。第l层的插值点x的特征为： f^(l)(x) =\\frac{ \\sum_{i=1}^3 w_i(x) f^(l) (x_i)}{\\sum_{i=1}^3w_i(x)}其中，w_i(x)=\\frac{1}{d(x, x_i)}，是距离的倒数。x_1,x_2,x_3是x在l层上最近的3个邻居。然后用1x1卷积将不同级别的插值减少到相同的维度，再将各层次的特征连接到一起，作为该点的点嵌入特征f。 Feature Expansion我们需要扩展特征空间中特征的个数，这可以看作是扩展点的数量，因为点和特征是可以互换的。图像相关任务中的特征上采样通常用反卷积或者插值的方法，但用在无序不规则的点云数据上并不合适。因此本文提出了一种基于子像素卷积层的特征扩展方法： f' = RS([C_1^2(C_1^1(f)), ..., C_r^2(C_r^1(f))])其中，C_i^1(·)和C_i^2(·)是两个1x1卷积的集合，RS(·)是一个reshape操作。N为输入点的数量，\\tilde{C}为特征的维度，目标得到rN个特征，r为上采样率。将N\\times \\tilde{C}扩展到rN \\times \\tilde{C}，然后通过两个各点独立的1 \\times 1的卷积核，得到rN \\times \\tilde{C_2}的张量。 由于C_i^1(·)生成的点集之间相关性可能太高，会导致重建的点之间太近，我们对每个特征集合增加一个卷积层，训练网络去学习这r个不同的卷积。当然也可以用其他更加高效的组卷积方式实现（如AlexNet，ResNeXt，Shufflenet等）。 Coordinate Reconstruction通过一系列全连接层将每个点扩展特征rN \\times C_2重建成的点坐标rN \\times 3。 联合损失函数结合重建损失Reconstruction loss和排斥损失Repulsion loss建立了联合损失函数。 Reconstruction loss为了将点放在潜在的物体表面上，我们建议使用Earth Mover’s distance( EMD) 作为我们的重建损失，来评估预测点云S_{pred} ⊆R^3和实际点云S_{groundtruth} ⊆R^3之间的相似性:其中f为映射S_{pred}\\rightarrow S_{groundtruth}。 实际上，Chamfer Distance(CD) 是评估两个点集之间相似性的另一个候选。然而，与CD相比，EMD可以更好地捕捉形状，以鼓励输出点靠近底层物体表面。因此，我们选择在重建损失中使用EMD。 Repulsion loss虽然具有重建损失的训练可以在底层物体表面上生成点，但是生成的点往往位于原始点附近。为了更均匀地分布生成的点，我们设计了排斥损失Repulsion loss，表示为:其中\\tilde N = rN是上采样完了以后的输出点个数，K(i)是点x_i的K近邻点，||\\bullet ||代表二范数\\eta(r)=-r被称为排斥项，它是一个递减的函数，如果x_i距离他的K近邻K(i)过于接近。inline为了使x_i只有过于接近他的K近邻点的时候才收到惩罚，我们增加了两条约束：i)只考虑点x_{i'}为x_{i}的K近邻时的情况；(ii)将快速衰减的权重函w(r)=e^{-r^2/h^2}加入排斥损失中。 Joint Loss Function联合损失函数具有如下的形式： L(\\theta) = L_{rec}+\\alpha L_{rep} + \\beta ||\\theta||^2其中\\theta代表整个网络的参数，\\beta ||\\theta||^2为正则化惩罚项。 模型比较为了定量评估输出点集的质量，我们制定了两个度量来测量输出点和ground truth之间的偏差，以及输出点的分布均匀性。 偏差度量：为每个预测点x_i找到网格上最近的点\\hat x_i，并计算它们之间的距离。然后，我们计算所有点的平均值和标准偏差。 均匀性度量：将D个大小相等的disk随机放在物体表面上，并计算disk内部点数的标准偏差。进一步标准化每个对象的密度，然后计算测试数据集中所有对象上点集的整体均匀性。因此，将标准化均匀系数normalized uniformity coefficient(NUC)与disk面积百分比p定义为:NUC数值越小，表示点分布越均匀。","link":"/2019/10/31/PU-Net点云上采样网络论文笔记/"},{"title":"PointNet家族论文笔记","text":"PointNet和PointNet++的论文笔记。 PointNet CVPR2017《PointNet: Deep Learning on Point Sets for 3D Classification and Segmentation》在线介绍：http://stanford.edu/~rqi/pointnet/paper下载：点击这里 简介提出了一种新型的处理点云数据的深度学习模型-PointNet，并验证了它能够用于点云数据的多种认知任务，如分类、语义分割和目标识别。 共享多层感知机(Shared MLP) + max pool（置换不变性），逐级映射到高层表示 刚体变换（包括平移、旋转、反转）: 增加T-net(transform net)， 将输入的三维点云进行变形，得到规范的数据，能够映射到高维 解决问题第一次直接在三维点云数据上建立深度学习模型，处理point cloud的数据无序性？。 思想学习每个点的空间编码，然后利用对称函数把所有单独的点特征聚集成一个全局点云标记特征。网络有两个亮点： 空间变换网络解决旋转问题三维的STN可以通过学习点云本身的位置信息学习到一个最有利于网络进行分类或分割的DxD旋转矩阵（D代表特征维度，pointnet中D采用3和64）。至于其中的原理，我的理解是，通过控制最后的loss来对变换矩阵进行调整，pointnet并不关心最后真正做了什么变换，只要有利于最后的结果都可以。pointnet采用了两次STN，第一次input transform是对空间中点云进行调整，直观上理解是旋转出一个更有利于分类或分割的角度，比如把物体转到正面；第二次feature transform是对提取出的64维特征进行对齐，即在特征层面对点云进行变换。 maxpooling解决无序性问题网络对每个点进行了一定程度的特征提取之后，max pooling可以对点云的整体提取出global feature。 网络设计对称设计：通过一个多层感知机网络近似h函数，再用g对称函数。该网络通过使用MaxPooling作为对称函数设计来处理点云模型的无序性的，也就是说无论输入的顺序是怎样的，maxpooling都会输出相同的结果。对称函数就是类似自然数加法那样的操作，调换输入顺序输出不变。 上图中蓝色部分是分类网络，黄色部分是分割网络。分割网络需要cancat global features和local features。（但实际上local features并没有充分地提取局部特征，例如密度表征等，所以后来才提出了其改进版PointNet++，但速度更慢）其中，mlp是通过共享权重的卷积实现的，第一层卷积核大小是1x3（因为每个点的维度是xyz），之后的每一层卷积核大小都是1x1。即特征提取层只是把每个点连接起来而已。经过两个空间变换网络和两个mlp之后，对每一个点提取1024维特征，经过maxpool变成1x1024的全局特征。再经过一个mlp（代码中运用全连接）得到k个score。分类网络最后接的loss是softmax。网络结构中，两处用到了STN网络。stn生成仿射矩阵后对每个points都施加相同的仿射变换，不同sample的仿射矩阵不一样，都需要用stn网络计算出来。 为什么用64x64和64x128x1024的感知机? 实验结果不足：很容易想到的一点就是Pointnet的大部分或说几乎全部的处理都是针对单个采样点的，无论提多么精细的feature都是针对某一个采样点的，而整合所有采样点特征的网络只有那个maxpooling，没错，甚至连可训练的变量都没有，只有一个maxpool。因此，网络对模型局部信息的提取能力远不如卷积神经网络来的那么solid。 NoteQ: T-Net在网络结构中起的本质作用是什么？需要预训练吗？A: T-Net 是一个预测特征空间变换矩阵的子网络，它从输入数据中学习出与特征空间维度一致的变换矩阵，然后用这个变换矩阵与原始数据向乘，实现对输入特征空间的变换操作，使得后续的每一个点都与输入数据中的每一个点都有关系。通过这样的数据融合，实现对原始点云数据包含特征的逐级抽象 PointNet++ NIPS2017 《PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space》project page: http://stanford/edu/~rqi/pointnet2/paper source: http://papers.nips.cc/paper/7095-pointnet-deep-hierarchical-feature-learning-on-point-sets-in-a-metric-space 简介在PointNet的基础上，模仿CNN卷积的特点（在较低水平，神经元有较小的感受野，而在较高水平，具有较大的感受野），通过分层特征提取来利用local structure。通过利用度量空间距离，本文的网络能够学习到更大的上下文规模的局部特征（local features）。采样的点云集合通常有不同的密度，作者提出了新的集合学习层去自适应地结合多尺度特征。 结果特征表达更加高效、稳健，但是计算代价高且慢（FPS和MSG部分慢？）。 问题 How to generate the partitioning of the point set(如何划分点集)定义每个分区为一个有质心和规模的邻域球，质心由FPS(Farthest Point Sampling)进行选择， How to abstract sets of points or local features through feature learner(如何通过feature learner抽象出点集和local features)局部邻域球（local neighborhood ball）进行了多尺度的邻域特征提取，在训练期间辅助随机输入丢失，网络自适应地加权在不同尺度下检测的模式并组合多尺度特征。 思考？: CNN中确定局部子集规模(local partition scale)的是kernel size的大小，用越小的kernel，CNN的效果会更好(《Rethinking the Inception Architecture for Computer Vision》中提出，可以用2个连续的3x3卷积层代替单个5x5卷积层，保持感受野范围的同时又减少了参数量)。但是点集上的实验给了反证，因为太少的点采样效果不好。TODO：能否将划分子集的网络层加深呢？ 思想 采用了分层结构来处理局部特征(fine-grained patterns)在原PointNet中，对于part segmentation以及scene semantic sparsing，即需要得到每个点的得分时，处理办法是直接将点特征与全局特征结合到一块进行处理，忽略了局部特征这一中间步骤，例如在一个场景中，我们先识别出椅子是椅子，桌子是桌子等这些局部特征。是否在最终对每个点进行分类时，是否会更加准确呢？所以PointNet++采用了分层结构用于处理局部特征，可以更好地处理fine-grained patterns： 根据小的邻域提取捕捉几何结构的local features 将local features分组到更大的单元去进行处理，去产生high level features。 在网络结构中加入密度适应（density）使得分割更加准确合理点云数据的一个特征是数据密度不同，体现出近多远少等问题，而在密度不同的情况下，使用统一的模板处理这些数据显然是不对的，针对稀疏点云训练的模型可能无法识别细粒度的局部结构。因此PointNet++的作者提出了密度适应的网络结构。 网络设计层次点集特征学习可以同时用来做分割和分类工作，上图可视化了单尺度集群方法。 1. 局部特征提取：PointNet++由一些连续的set abstraction部分分层抽取特征，每个set abstraction部分分为三部分：采样层Sampling layer, 分组层Grouping layer和特征提取层PointNet layer。 采样层用递归式的FPS，从输入的点云中选取局部特征球中心点的点集。 分组层根据这些中心点寻找邻域来构建局部区域点集。有两种确定邻域的方法：Ball Query查找中心点半径内的所有点，kNN查找固定数量的邻域。Ball Query保证了固定的区域比例，因此对于类似语义点标记的局部模式识别任务更好。 特征提取层通过小型pointnet网络进行卷积和pooling，得到的特征作为中心点的特征，将这些局部特征编码成特征向量。这样层数加深后，得到的中心点个数越来越少，但每个中心点包含的信息越来越多。（problem：计算出的特征只赋给中心点吗？邻域里其他的点要不要也加权计算后的特征呢？） 2. 密度适应：提出了两种密度适应层来分组局部特征并且组合这些特征。 多尺度分组 MSG（multi-scale grouping）是直观且简单的方法，用ramdom input dropout对输入点云进行抛弃，得到不同尺度的采样，并经过set abstraction后将这些采样层的的多尺度特征联合。 多分辨率分组 MRG（multi-resolution grouping）MSG由于要对每个中心点跑大规模邻域的特征提取，计算开销很高。尤其是在low level上中心点的个数很多，时间成本很高。因此提出多分辨率分组的方法。如图所示，新特征通过两部分连接起来，左边是通过一个set abstraction得到的特征向量，右边是用一个PointNet直接处理所有局部区域点得到的特征向量。点云密度不均时，可以通过判断当前局部区域的密度给左右两个特征向量不同权重。 分割网络分割网络的实现思想是将点云提取一个全局的特征之后，再通过全局的特征逐步上采样。 最简单的是广播复制Broadcasting，即将每个点的附近的点的特征都变成和这个点一样，但是这样的方法会使得没有办法处理一些范围相冲突的点，或者范围没有覆盖到的点。因此在论文中作者采用的是线性插值的方法去做特征传播，k近邻反距离加权法（inverse distance weighted average）距离越远的点权重越小。代码中p=2, k=3。 数据集MNIST（2D物体）ModelNet40（3D刚性物体）SHREC15（3D非刚性物体）ScanNet（真实3D室内场景） 结果MRG没有MSG效果好，但是MSG计算复杂度很高","link":"/2019/10/22/PointNet家族论文笔记/"},{"title":"markdown基本语法","text":"Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。 Markdown 为记录思想和分享知识提供更专业的工具。 可以使用 Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法需要在#后跟个空格再写文字。 示例： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 示例： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;直到n个 示例： 这是引用的内容 这是引用的内容 这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 * 都可以。 示例： —- 效果如下： 可以看到，显示效果是一样的。 图片语法： 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 效果如下： 超链接语法：超链接名title可加可不加 示例： hexogithub 效果如下：hexogithub 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例Github 列表 无序列表语法：无序列表用 - + * 任何一种都可以 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 有序列表语法：数字加点 1.列表内容2.列表内容3.列表内容 注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格语法： 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码：代码之间分别用一个反引号包起来 代码内容 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行(12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 代码... 代码... 代码...(```)注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。示例：单行代码&gt; `create database hero;`代码块&gt; (```)&gt; function fun(){&gt; echo &quot;这是一句非常牛逼的代码&quot;;&gt; }&gt; fun();&gt; (```)效果如下：单行代码`create database hero;`代码块function fun(){ echo &quot;这是一句非常牛逼的代码&quot;;}fun();### 流程图### 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)- [ ] 支持以 PDF 格式导出文稿- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率- [x] 新增 Todo 列表功能- [x] 修复 LaTex 公式渲染问题- [x] 新增 LaTex 公式编号功能### 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$### 高亮一段代码[^code]```python@requires_authorizationclass SomeClass: passif __name__ == &apos;__main__&apos;: # A comment print &apos;hello world&apos; 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 绘制表格 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 LaTeX. 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 ↩ code. 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。 ↩","link":"/2018/12/22/markdown基本语法/"},{"title":"hexo及icarus主题个性定制","text":"icarus个性定制配置修改的一些内容。 前言此篇不介绍hexo的搭建，网上教程已经很完善，这里讲我用icarus做的一些个性化配置。 语言切换Icarus提供多语言切换，默认是英文的。为了改成中文，进入项目目录，修改_config.yml 中的language: zh-CN 增加文章字间距icarus中文显示字体有点挤。在icarus/xiansource/css/style.styl中.article .content的部分加上letter-spacing: 0.08rem; 加宽中心文章的布局icarus默认的文章区域比较窄，我想改得宽一点，突出文章内容。解决办法： 打开themes/icarus/layout/layout.ejs 改变main_column_class()中case 3的返回值 原值为is-8-tablet is-8-desktop is-6-widescreen 我改成了is-10-tablet is-10-desktop is-8-widescreen 但是重新部署的时候，会出现整体内容不居中解决办法：通过开发者工具可以看到生成的container.saas文件里，margin-left和margin-right都是auto在icarus/source/css/style.sytl中加上属性12345678910111213141516171819 .container margin-left: 2rem; margin-right: 2rem;``同时为了让navbar居中把在同一个文件中@media screen and (mid-width: screen-fullhd)的部分里把@media screen and (min-width: screen-fullhd) 部分改成```css @media screen and (min-width: screen-fullhd) .is-3-column .container max-width: 1600px margin-left: 2rem; margin-right: 2rem; .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap margin-left: auto; margin-right: auto; .is-1-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap 更改友情链接布局icarus本身的链接布局是一列一列的，左边昵称，右边链接。我为了省空间，把跳转链接直接加到昵称上，让两个昵称左右分布。更改links.ejs文件里div class=&quot;card-content&quot;部分123456789101112131415161718192021222324&lt;div class=\"menu links\"&gt; &lt;h3 class=\"menu-label\"&gt; &lt;%= __('widget.links') %&gt; &lt;/h3&gt; &lt;ul class=\"menu-list\"&gt; &lt;% let flag = 1; for (let i in links) { %&gt; &lt;% if (flag == 1) { %&gt; &lt;li&gt; &lt;a class=\"level is-mobile\" href=\"&lt;%- links[i] %&gt;\" target=\"_blank\"&gt; &lt;span class=\"level-left\" style=\"text-decoration: underline\"&gt; &lt;span class=\"level-item\"&gt;&lt;%= i %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;% flag = 0;} else {%&gt; &lt;a class=\"level is-mobile\" href=\"&lt;%- links[i] %&gt;\" target=\"_blank\"&gt; &lt;span class=\"level-right\" style=\"text-decoration: underline\"&gt; &lt;span class=\"level-item\"&gt;&lt;%= i %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;% flag = 1;} %&gt; &lt;% } %&gt; &lt;/ul&gt;&lt;/div&gt; style.style中widget部分改为123456789101112.widget .media border: none .media + .media margin-top: 0 .menu-list li ul margin-right: 0 a.level display: flex .links .menu-list a.level display: inline-block 给博客增加自定义目录在主题的配置文件config.yml里添加：12345 widgets: - type: toc position: lef` 对于需要添加目录的博客，在header中添加toc: true 为博客增加分享功能icarus提供多个分享插件。 AddThis AddToAny Baidu Share Share.js ShareThis 我选择share.js插件，它可以一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等社交网站。设置步骤：123_config.ymlshare: type: sharejs 给blog增加点击爱心效果创建js文件在/themes/icarus/source/js/src下新建文件clicklove.js，接着把该链接下的代码拷贝粘贴到clicklove.js文件中。123456789101112131415161718192021222324252627282930313233343536373839404142!function(e,t,a){ function n(){ c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r() } function r(){ for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\"); requestAnimationFrame(r) } function o(){ var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e){ t&amp;&amp;t(),i(e) } }function i(e){ var a=t.createElement(\"div\"); a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a) } function c(e){ var a=t.createElement(\"style\");a.type=\"text/css\"; try{ a.appendChild(t.createTextNode(e)) } catch(t){ a.styleSheet.cssText=e } t.getElementsByTagName(\"head\")[0].appendChild(a) } function s(){ return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\" } var d=[]; e.requestAnimationFrame=function(){ return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){ setTimeout(e,1e3/60) } }(), n()}(window,document); 修改layout.ejs文件在/theme/icarus/layout/layout.ejs的&lt;!DOCTYPE html&gt;之后增加语句1&lt;script src=\"/js/clicklove.js\"&gt;&lt;/script&gt; 增加看板娘插件live2D安装使用 npm 安装：在 Hexo 项目的根目录运行命令：1npm install --save hexo-helper-live2d 3.0.1 版本存在的 bug：存在代码注入 bug，与 hexo-tag-dplayer 插件产生冲突，导致相关脚本无法加载。解决方法：在项目中使用 npm 命令手动卸载 “hexo-tag-dplayer”: “^0.3.1”。参阅GitHub issue 给文章日期/分类/标签增加图标Icarus主题下的这些没有图标，但我想加图标的话怎么办？hexo里可以使用FontAwesome图标CSS样式加上字体库实现图标的引用。其它网站开发中也可以使用。 引入Icarus主题源文件中已经引用了CSS文件，可直接跳过这部分。 使用图标之前需要引入 CSS 文件,这里选用 FontAwesome 4.4.0 版本。1&lt;link href=\"//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css\" rel=\"stylesheet\"&gt; 当然,还可以使用离线包,我们可以去官网下载它。http://fontawesome.io/ 使用1&lt;i class=\"fa fa-home\"&gt;&lt;/i&gt; 图标CSS清单可参考博客 文章做成两格布局文件改动includes/helpers/layout.js中12hexo.extend.helper.register(&apos;column_count&apos;, function () { let columns = 1; 后添加123if (this.page.__post === true || this.page.__page === true) { return 2;} layout/common/widget.ejs中1&lt;%- partial('common/widget', { position: 'right' }) %&gt; 改成123&lt;% if (page.__page !== true &amp;&amp; page.__post !== true) { %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt;&lt;% } %&gt; layout/layout.ejs中hexo.extend.helper.register('column_count', function () { let columns = 1;后添加123 if (this.page.__post === true || this.page.__page === true) { return 2;} 但这样左边栏显示变宽了，我觉得不是很好看，怎么办呢？ 把layout/common/widget.ejs中side_column_class()的case 2的返回值改成return 'is-4-tablet is-4-desktop is-3-widescreen';就好啦！ 更多细则可以参考作者项目的issue(作者是个勤于回复的人！特别好！) 添加文章更新时间 修改（博客主目录/themes/icarus/layout/common/article.ejs文件，在&lt;time class=&quot;level-item has-text-grey&quot; datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot;&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;标签后添加 1234&lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt; &lt;i class=\"fas fa-calendar-check\"&gt;&amp;nbsp&lt;/i&gt; &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.updated) %&gt;\"&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;&lt;% } %&gt; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/icarus/languages/zh_CN.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/icarus/_config.yml，增加一行 1display_updated: true 写文章的时候可以直接在文章开头设置更新时间updated: 2018-01-01 12:00:00没有这参数的话将会显示md文件的修改日期 优化访问速度To be continued…","link":"/2018/12/24/icarus个性定制/"},{"title":"关于我和3DGNN论文及源码的爱恨情仇","text":"配这篇论文源码的环境的过程实在是太艰难了。也 太 艰 难 了。究竟是什么样的狠人才会用matlab + caffe的环境啊！！ 参考论文3D Graph Neural Networks for RGBD Semantic Segmentation源码在仓库3DGNN 预先配好的环境：Ubuntu 16.04(64bit) cuda: 8.0 cudnn: 5.1 OpenCV: 3.4.3 Matlab: R2016b 显卡: GeForce 1080Ti x2 安装MATLAB我的服务器是无图形界面的，安装MATLAB的时候要开启mode=silent。并且因此无法通过网络下载matlab需要用到的toolbox库，所以必须要挂载iso镜像。 在进行make matcaffe之前，要解决几个编译器版本的问题。在安装路径xxx/MATLAB/R2016b/sys/os/glnxa64下把 libstdc++.so.6 重命名为 libstdc++.so.6_back12sudo mv libstdc++.so.6 libstdc++.so.6_backsudo ldconfig 这时Matlab找不到libstdc++.so.6，会找到系统文件下的/usr/lib/libstdc++.so.6 处理这个问题的另外一个办法是建立一个soft link（为一个lib建立一个重定向，以后要找这个名字的lib，会定向到指定的lib那里）123cd /usr/local/MATLAB/R2016b/sys/os/glnxa64sudo rm libstdc++.so.6sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21 libstdc++.so.6 安装caffemake all -j8 make test -j8 make runtest -j8 错误信息: 找不到hdf5 fatal error: hdf5.h: No such file or directory 解决办法一在caffe文件夹下的MakeFile.configINCLUDE_DIRS := 最后加上 /usr/include/hdf5/serial/LIBRARY_DIRS := 最后加上 /usr/lib/x86_64-linux-gnu/hdf5/serial/保存，重新编译即可。 解决办法二（如果有root权限）增加软连接：cd /usr/lib/x86_64-linux-gnusudo ln -s libhdf5_serial.so.8.0.2 libhdf5.sosudo ln -s libhdf5_serial_hl.so.8.0.2 libhdf5_hl.so 错误信息：找不到-lhdf5 LD -o .build_release/lib/libcaffe.so.1.0.0-rc3/usr/bin/ld: cannot find -lhdf5collect2: error: ld returned 1 exit statusMakefile:563: recipe for target ‘.build_release/lib/libcaffe.so.1.0.0-rc3’ failedmake: * [.build_release/lib/libcaffe.so.1.0.0-rc3] Error 1 解决办法：改Makefile里LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_serial_hl hdf5_serial 错误信息：关于cudnn In file included from ./include/caffe/util/device_alternate.hpp:40:0, from ./include/caffe/common.hpp:19, from src/caffe/common.cpp:7:./include/caffe/util/cudnn.hpp: In function ‘void caffe::cudnn::createPoolingDesc(cudnnPoolingStruct, caffe::PoolingParameter_PoolMethod, cudnnPoolingMode_t, int, int, int, int, int, int)’:./include/caffe/util/cudnn.hpp:127:41: error: too few arguments to function ‘cudnnStatus_t cudnnSetPooling2dDescriptor(cudnnPoolingDescriptor_t, cudnnPoolingMode_t, cudnnNanPropagation_t, int, int, int, int, int, int)’ pad_h, pad_w, stride_h, stride_w)); ^./include/caffe/util/cudnn.hpp:15:28: note: in definition of macro ‘CUDNN_CHECK’ cudnnStatus_t status = condition; \\ ^In file included from ./include/caffe/util/cudnn.hpp:5:0, from ./include/caffe/util/device_alternate.hpp:40, from ./include/caffe/common.hpp:19, from src/caffe/common.cpp:7:/usr/local/cuda-7.5//include/cudnn.h:803:27: note: declared here cudnnStatus_t CUDNNWINAPI cudnnSetPooling2dDescriptor( ^make: [.build_release/src/caffe/common.o] Error 1 参考链接(https://blog.csdn.net/u011070171/article/details/52292680)[https://blog.csdn.net/u011070171/article/details/52292680] 这是因为当前版本的caffe的cudnn实现与系统所安装的cudnn的版本不一致引起的。 解决办法(害怕自己有失误的宝宝要记得备份哦)： git clone最新版本的caffe源码 将./include/caffe/util/cudnn.hpp 换成最新版的caffe里的cudnn的实现，即相应的cudnn.hpp. 将./include/caffe/layers里的，所有以cudnn开头的文件，例如cudnn_conv_layer.hpp。 都替换成最新版的caffe里的相应的同名文件。 将./src/caffe/layers里的，所有以cudnn开头，以.cpp或者.cu结尾的文件，例如cudnn_lrn_layer.cu，cudnn_pooling_layer.cpp，cudnn_sigmoid_layer.cu，都替换成最新版的caffe里的相应的同名文件。 错误信息：cannot find -lopencv_dep_cudart /usr/bin/ld: cannot find -lopencv_dep_cudartcollect2: error: ld returned 1 exit statussrc/caffe/CMakeFiles/caffe.dir/build.make:4285: recipe for target ‘lib/libcaffe.so.1.0.0-rc3’ failedmake[2]: [lib/libcaffe.so.1.0.0-rc3] Error 1CMakeFiles/Makefile2:272: recipe for target ‘src/caffe/CMakeFiles/caffe.dir/all’ failedmake[1]: [src/caffe/CMakeFiles/caffe.dir/all] Error 2Makefile:127: recipe for target ‘all’ failedmake: * [all] Error 2 解决办法：需要在bash里set CUDA_USE_STATIC_CUDA_RUNTIME=off，再make 错误信息：make的时候libcaffe.so出错 undefined reference to cv:: .build_release/lib/libcaffe.so: undefined reference to `cv::_InputArray::_InputArray(cv::Mat const&amp;)’ .build_release/lib/libcaffe.so: undefined reference to `cv::imdecode(cv::_InputArray const&amp;, int)’ .build_release/lib/libcaffe.so: undefined reference to `cv::imencode(std::__cxx11::basic_string","link":"/2019/03/23/关于我和3DGNN论文及源码的爱恨情仇/"},{"title":"简洁清爽的Stylus语法","text":"Stylus是一个基于Node.js的CSS的预处理框架。其本质上做的事情与sass/less等类似。Stylus比less更强大。icarus主题中用到了stylus。 Stylus介绍Stylus是一个基于Node.js的CSS的预处理框架。可以说是一种新型语言，其本质上做的事情与sass/less等类似。Stylus比less更强大；比sass更符合我们的思路。 它是一个CSS的预处理框架，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，所以 Stylus是一种新型语言，可以创建健壮的、动态的、富有表现力的CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似，应该是有很多借鉴，所以近似脚本的方式去写CSS代码。 Stylus默认使用 .styl 的作为文件扩展名，支持多样性的CSS语法。 Stylus功能上更为强壮，和js联系更加紧密。 对于开发来说，CSS的弱点在于静态化。我们需要一个真正能提高开发效率的工具，LESS， SASS都在这方面做了一些贡献。 安装全局安装，安装之前你需要先安装nodejs。1$ npm install stylus -g 苹果电脑（mac系统）以上命令或许不成功 mac系统建议以下方式进行安装1$ sudo npm install stylus -g 这样就算是安装完Stylus了，也可以正常使用Stylus。 123456789101112131415161718192021Usage: stylus [options] [command] [&lt; in [&gt; out]] [file|dir ...]Commands: help &lt;prop&gt; Opens help info for &lt;prop&gt; in your default browser. (OS X only)Options: -u, --use &lt;path&gt; Utilize the stylus plugin at &lt;path&gt; -i, --interactive Start interactive REPL -w, --watch Watch file(s) for changes and re-compile -o, --out &lt;dir&gt; Output to &lt;dir&gt; when passing files -C, --css &lt;src&gt; [dest] Convert CSS input to Stylus -I, --include &lt;path&gt; Add &lt;path&gt; to lookup paths -c, --compress Compress CSS output -d, --compare Display input along with output -f, --firebug Emits debug infos in the generated css that can be used by the FireStylus Firebug plugin -l, --line-numbers Emits comments in the generated CSS indicating the corresponding Stylus line -V, --version Display the version of Stylus -h, --help Display help information 生成CSS命令行中建立一个stylusExample/，再在里面建立 src 目录专门存放 stylus 文件，在里面建立 example.styl 文件。然后在 stylusExample 目录下面执行下面命令1$ stylus --compress src/ 输出compiled src/example.css ，这个时候表示你生成成功了，带上–compress参数表示你生成压缩的CSS文件。123$ stylus --css css/example.css css/out.styl CSS转换成styl $ stylus help box-shadow CSS属性的帮助 $ stylus --css test.css 输出基本名一致的.styl文件 应用效果Try Stylus!stylus123body,html margin:0 padding:0 编译成12345body,html { margin: 0; padding: 0;} stylus : 强大的功能丰富的语言1234567891011121314151617181920-pos(type, args) i = 0 position: unquote(type) {args[i]}: args[i + 1] is a 'unit' ? args[i += 1] : 0 {args[i += 1]}: args[i + 1] is a 'unit' ? args[i += 1] : 0absolute() -pos('absolute', arguments)fixed() -pos('fixed', arguments) #prompt absolute: top 150px left 5px width: 200px margin-left: -(@width / 2) #logo fixed: top left 编译成123456789101112#prompt { position: absolute; top: 150px; left: 5px; width: 200px; margin-left: -100px; #logo { position: fixed; top: 0; left: 0;} nibStylus插件stylus123@import 'nib'body background: linear-gradient(20px top, white, black) 编译成1234567body { background: -webkit-linear-gradient(20px top, #fff, #000); background: -moz-linear-gradient(20px top, #fff, #000); background: -o-linear-gradient(20px top, #fff, #000); background: -ms-linear-gradient(20px top, #fff, #000); background: linear-gradient(20px top, #fff, #000);} Nesting(嵌套)stylus123header #logo border:1px solid red 编译成123header #logo { border: 1px solid #f00;} Flexible syntax(灵活的用法)更多详细示例可参考stylus中文文档，或者stylus官方文档。 stylus1234567891011body font 14px/1.5 Helvetica, arial, sans-serif button button.button input[type='button'] input[type='submit'] border-radius 5pxheader #logo,div font-size:14px 编译成123456789101112body { font: 14px/1.5 Helvetica, arial, sans-serif;}body button,body button.button,body input[type='button'] { border-radius: 5px;}header #logo,header div { font-size: 14px;} Flexible &amp;(灵活&amp;)stylus123456789ul li a display: block color: blue padding: 5px html.ie &amp; padding: 6px &amp;:hover color: red 编译成1234567891011ul li a { display: block; color: #00f; padding: 5px;}html.ie ul li a { padding: 6px;}ul li a:hover { color: #f00;} Functions 方法返回值带参数stylus1234567border-radius(val) -webkit-border-radius: val -moz-border-radius: val border-radius: valbutton border-radius(5px); 编译成123456button { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;}Transparent mixins 不带参数stylus1234567border-radius() -webkit-border-radius: arguments -moz-border-radius: arguments border-radius: argumentsbutton border-radius: 5px 10px; 编译成12345button { -webkit-border-radius: 5px 10px; -moz-border-radius: 5px 10px; border-radius: 5px 10px;} 默认参数不带参数1234567891011stylusadd(a, b = a) a + badd(10, 5)// =&gt; 15add(10)// =&gt; 20函数体 通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。1234567add(a, b = a) a = unit(a, px) b = unit(b, px) a + badd(15%, 10deg)// =&gt; 25 多个返回值通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。12345sizes() 15px 10pxsizes()[0]// =&gt; 15px Variables(变量)常用方法stylus123font-size = 14pxbody font font-size Arial, sans-seri 编译成123body { font: 14px Arial, sans-seri;} 变量放在属性中stylus123456#prompt position: absolute top: 150px left: 50% width: w = 200px margin-left: -(w / 2) 编译成1234567 #prompt { position: absolute; top: 150px; left: 50%; width: 200px; margin-left: -100px;} 块属性访问引用stylus1234#prompt position: absolute width: 200px margin-left: -(@width / 2) 编译成12345 #prompt { position: absolute; width: 200px; margin-left: -100px;} 属性有条件地定义属性stylus:指定z-index值为1，但是，只有在z-index之前未指定的时候才这样：12345678position() position: arguments z-index: 1 unless @z-index #logo z-index: 20 position: absolute #logo2 position: absolute 编译成12345678 #logo { z-index: 20; position: absolute;} #logo2 { position: absolute; z-index: 1;} 向上冒泡stylus:属性会“向上冒泡”查找堆栈直到被发现，或者返回null（如果属性搞不定）下面这个例子，@color被弄成了blue.1234567body color: red ul li color: blue a background-color: @color 编译成123456789body { color: #f00;}body ul li { color: #00f;}body ul li a { background-color: #00f;} Iteration(迭代)stylus1234table for row in 1 2 3 4 5 tr:nth-child({row}) height: 10px * row 编译成123456789101112131415table tr:nth-child(1) { height: 10px;}table tr:nth-child(2) { height: 20px;}table tr:nth-child(3) { height: 30px;}table tr:nth-child(4) { height: 40px;}table tr:nth-child(5) { height: 50px;} Interpolation(插值)stylus123456789vendors = webkit moz o ms officialborder-radius() for vendor in vendors if vendor == official border-radius: arguments else -{vendor}-border-radius: arguments#content border-radius: 5px 编译成1234567#content { -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; -ms-border-radius: 5px; border-radius: 5px;} Operators(运算符)运算符优先级：下表运算符优先级，从最高到最低：123456789101112131415161718. [] ! ~ + - is defined ** * / % + - ... .. &lt;= &gt;= &lt; &gt; in == is != is not isnt is a &amp;&amp; and || or ?: = := ?= += -= *= /= %= not if unless@import@import \"reset.css\" 当使用@import没有.css扩展，会被认为是Stylus片段（如：@import “mixins/border-radius”）。 @import工作原理为：遍历目录队列，并检查任意目录中是否有该文件（类似node的require.paths）。该队列默认为单一路径，从filename选项的dirname衍生而来。 因此，如果你的文件名是/tmp/testing/stylus/main.styl，导入将显现为/tmp/testing/stylus/。 @import也支持索引形式。这意味着当你@import blueprint, 则会理解成blueprint.styl或blueprint/index.styl. 对于库而言，这很有用，既可以展示所有特征与功能，同时又能导入特征子集。 @font-facestylus123456@font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf).ingeo font-family Geo 编译成123456789@font-face { font-family: Geo; font-style: normal; src: url(“fonts/geo_sans_light/GensansLight.ttf”); } .ingeo { font-family: Geo; } @media stylus1234@media print #header #footer display none 编译成1234567@media print { #header, #footer { display: none; } } @keyframes stylus1234567@keyframes pulse 0% background-color red transform scale(1.0) rotate(0deg) 33% background-color blue -webkit-transform scale(1.1) rotate(-5deg) 编译成12345678910111213141516171819202122232425262728293031323334353637383940@-moz-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@-webkit-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@-o-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }} CSS字面量(CSS Literal)stylus12345@css { body { font: 14px; }} 编译成123body { font: 14px;}","link":"/2018/12/31/简洁清爽的Stylus语法/"},{"title":"面向对象设计原则","text":"一些基本的面向对象设计原则。 面向对象设计原则1. SRP所谓SRP原则，即：Single Responsibility Principle，单一职责原则。原始定义如下： There should never be more than one reason for a class to change.(只有一个引起类改变的原因) 在面向对象编程领域中，单一职责原则（Single responsibility principle）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。 单一职责的好处： 类的复杂性降低，实现什么职责都有清晰明确的定义; 可读性提高，复杂性降低，可维护性提高; 变更引起的风险降低。 单一职责原则的注意点： 单一职责最难划分的是职责。 单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。 2. LSP所谓LSP原则，即：Liskov Substitution principle，里氏替换原则。原始定义如下： Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象） 更通俗的定义即为：子类可以扩展父类的功能，但不能改变父类原有的功能。里氏替换原则包含了以下4层含义： 子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。 子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。 覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。 覆盖或实现父类的方法时输出结果可以被缩小。 优点： 提高代码的重用性，子类拥有父类的方法和属性； 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性； 缺点： 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性； 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。 3. ISP所谓ISP原则，即：Interface Segregation Principle，接口隔离原则。原始定义如下： Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。) 即，接口尽量细化，接口中的方法尽量少。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 4. OCP所谓OCP原则，即：Open Closed Principle，开闭原则。原始定义如下： software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭) 开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：对扩展开放，对修改关闭。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。 软件系统中包含的各种组件，例如模块（Module）、类（Class）以及功能（Function）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。 实现开闭原则的关键就在于“抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。 开闭原则的好处： 可复用性好; 可维护性好。 5. DIP所谓DIP原则，即：Dependency Inversion Principle，依赖倒置原则。原始定义如下： High-level modules should not depend on low-level modules. Both should depend on abstractions.(高层模块不应该依赖低层模块，两者都应该依赖其抽象) Abstractions should not depend on details. Details should depend on abstractions.(抽象不应该依赖细节；细节应该依赖抽象) 面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。 依赖倒置原则主要有以下三层含义： 高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）； 抽象不应该依赖细节（具体实现）； 细节（具体实现）应该依赖抽象。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想就是面向接口编程。 6. LOD | LKP所谓LOD原则，即：Law of Demeter，迪米特法则，又叫最少知识原则（Least Knowledge Principle，简写LKP），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下： talk only to your immediate friends.(只与直接的朋友通信) 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。 迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。 7. CRP所谓CRP原则，即：Composite Reuse Principle，组合复用原则。 组合复用原则的核心思想是：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。 继承的缺点主要有以下几点： 继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。 基类的实现发生了改变，派生类的实现也不得不改变。 从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处： 新对象存取组成对象的唯一方法是通过组成对象的getter/setter方法。 组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。 组合复用所需要的依赖较少。 每一个新的类可以将焦点集中到一个任务上。 组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。 组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。 组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 使用继承时必须满足Is-A的关系是才能使用继承，而组合却是一种Has-A的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把Has-A当成了Is-A。","link":"/2019/01/12/面向对象设计原则/"},{"title":"给计算机科学毕业生的职业生涯建议","text":"无意中看到了这篇文章，文中讨论了如何选择要不要读博/选择创业公司还是大型企业等人生岔路，写得很好。 原文在 https://huyenchip.com/2018/10/08/career-advice-recent-cs-graduates.html Career advice for recent Computer Science graduatesEver since graduation, people have been asking me: “What’s now?” My answer has been an unequivocal: “I don’t know.” I used to think that by the time I finished my master’s degree, I would know what to do. I thought I’d be a “master”. Boy, was I wrong. School did little to prepare me for the post-school world. The academic environment provides continual feedback – you go off track a little and somebody is sure to let you know, even guide you back in. In real world, I have this fear that I’ll make a series of wrong decisions and nobody will tell me until it’s too late. A wrong job choice could cost me a few years, together with many opportunities that should have come with a better choice. When I looked up career advice for recent graduates online, most of the articles I found are concerned with how to get a job. I don’t want to sound like a snob, but realistically, for many recent grads with degrees in a demanding field like CS, the question is less about “what job can I get” and more about “what job should I get.” The availability of options doesn’t make the decision any easier. If anything, it threw someone with a massive case of FOMO like me into panic mode. I kept iterating through a series of questions: “Should I do a PhD?”, “Should I work for a big company or a startup?”, “Should I do my own startup?”, “Should I do engineering or something more social?”, “Should I just leave tech and pursue my passion for writing?” Over the last year, I’ve bothered many people, both in industry and academia, with these questions, and I’ve been so lucky that some of them were kind enough to sit me down and share their insights with me. As their advice was extremely helpful to me, I thought they might be also useful for others who will one day have to go through the process that I did. This article is an attempt to put into words the overwhelming thought process that I went through and the advice that I received. If you just want the advice without the storytelling, go straight to the last section. PhD or no PhDMy family farms in a small village in Vietnam, so the US academic world was obscure to me. I had no idea what a PhD was about, what people looked for in an PhD application, or how I should prepare for it if I ever wanted to apply. It was only when I started hanging out with PhD students at the beginning of my last year that I realized: “Wow, these people are really smart. They work on interesting problems. I want to be like them.” I quickly realized that “PhD or no PhD” is a topic that everyone seemed to have an opinion on. I also realized that 100% of the professors I talked to (aka those who already did their PhDs) told me I should do a PhD, and 100% of the people in industry told me I should not. Arguments supporting PhD include: You’ll have time to immerse yourself in research. If you want to become a professor, you have to do a PhD. Many top research labs such as DeepMind only interview PhD candidates. You won’t be too poor as AI internships pay well. Arguments supporting no-PhD include: There should be more people joining industry to bring research into production. By the time you finish your PhD, what you learn might no longer be relevant. Many professors have side gigs in the industry anyway so you can still work with them. You won’t be poor for the next five years. I decided to go with PhD. Since it was too late for me to prepare my PhD app, my professors suggested that I apply next year and spend the year in between strengthening my app, so I lined up a bunch of research internships. I graduated a quarter early and spent the next three months traveling. I wasn’t trying to find myself, but I stumbled upon it. During that time, I wrote every day for fun but didn’t read a single paper. I realized that I wanted to do PhD not because I wanted to do AI research, but because I wanted to be the person who did AI research. The notion strengthened when I caught up with my PhD friends and saw them spend every waking moment talking/thinking about AI – I didn’t share their passion. I wanted something different. How different? I was still trying to figure it out. Be a sell-out or follow your passionStanford offers a CS + English major. We used to joke that this major is for those who love writing but also want to get a job. Then a friend told me I was one of those. I didn’t major in CS for the sake of getting a job. I got hooked on it from the first introductory class because the subject was fascinating. I love engineering, but my three months off rekindled the belief that writing is the biggest love of my life. Since I already spent nearly 4 years pursuing my degrees in CS, I longed to have some time invested in writing. I was also afraid of settling into the stereotypical complacency of being just another software engineer in Silicon Valley. Pursuing your passion, it turns out, is not legal in the US when you’re an international student. To stay in the US, I have to have a job related to my field of study. I can, of course, go live in another country. The idea of living on some South American beach and writing is quite romantic. But AI is such a fast-changing field that I was already a bit disoriented after a quarter off – what if I couldn’t get back into the field after a year? Plus, logistics and immigration would be a nightmare. When I came to my professor with this dilemma, he was confused: “Why do you have to choose between engineering and writing? Why not both?” There are many people who are accomplished in their technical fields but also prolific writers. His unquestioning confidence in my ability to do both inspired my own confidence: “You’re right. I can do both.” I can work full time in tech and spend evenings/weekends writing. I used to spend an ungodly amount of time doing homework + teaching in college so I’m sure I can spare 20+ hr/week for writing. Should I do my own startup?Graduating from Stanford and living in Silicon Valley, I can’t escape the startup stereotype. Some have suggested that I’m the “startup type.” Some have even asked me to become their co-founder. I have, more than once, been tempted. The idea of building something from scratch is appealing. I’ll undoubtedly learn a lot, not only about the problem I try to solve but also about how to inspire people to work with me, how to raise money, how to run an organization, how to sell my product… I have a lot of friends doing their own startups and their lives are a lot of things, but never boring. Plus, they have a substantially larger chance of becoming billionaires than I do. Just reading news about this or that twenty-something raising millions of dollars makes it seem so easy. “Even that Yo app raised $1.5M!” someone once cited this as a reason why I should do a startup. But I’ve also seen enough of my friends to know that the startup life is stressful, cut-throat, and constrained by so many external factors. A fair share of my friends’ startups have already failed even though they are extremely smart, had great ideas and were backed by prestigious investors. Every time I feel like crap, I call up my startup friends, see their struggles, and feel glad that I’m not them. I might be in the minority here, but I think starting a company just for the sake of starting a company is devoid of reason and a waste of everyone’s time. I wouldn’t start my own company until I’ve got at least three things: A problem I want to dedicate my life to solve.A belief that I can solve it.A co-founder I can work with for an extended period of time without either of us trying to murder the other.Right now, I have none of those, so I’ll just hang around. I also think that working for someone else for a few years will much better prepare me, both finance-wise and skill-wise, to work for myself. Big companies or startupsWith the above factors internalized, I started my internship at NVIDIA. I cancelled my other internship plans and looked into full-time jobs. That was when my next big question arose: “Should I work for a big company or a startup?” I had interned at both a big company and a startup during my undergrad. My impressions were very much aligned with what is usually said of the trade-off between big company stability and startup high impact (and high risk). Among my friends who chose not to do PhD, about 40% went to big companies, 40% worked for startups, and the rest started their own companies. They all gave me compelling arguments. The pros/cons below, of course, vary from company to company. When I shared this concern with people, many told me to do what made me happy. While I appreciate the sentiment, this advice often left me even more confused. What does “happiness” even mean? How am I supposed to measure it? “Happiness” is also relative. Given enough time for adjustment, we can teach ourselves to be happy with just about anything. There were two pieces of advice that I found helpful. The first was: “Which one gives you a once-in-a-lifetime opportunity?” Do you believe that the startup you’re considering is working on something truly important and it’s your once-in-a-lifetime opportunity to contribute to it? Or do you believe that working for a tech giant is your once-in-a-lifetime opportunity? The second was: “What are you optimizing for?” An easy thing to optimize for is money. Some of my friends interview with multiple companies and go to the highest bidder. Some optimize for new experiences and choose a job that allows them to travel and meet a lot of people. Some optimize for prestige and go to the company that is the most well-known in their field. At this stage in my life, I optimize for personal growth. I want a job that gives me the most freedom to grow. It means that the job should allow me to work with great colleagues/mentors and challenge myself as much as possible. NVIDIAIn the end, I chose to stay at NVIDIA for the following reasons. 1. The cultureI’ve talked to many companies, and NVIDIA stands out as a big company that feels like a startup. One of the NVIDIA’s cultural tenets is SOL, speed of light – you have to move fast, much faster than a regular big organization. I talked to my manager about converting to full-time one afternoon and got my offer the next day. On Glassdoor, some say that the startup-like culture means a higher workload. Some find the lack of organizational structure at NVIDIA disorienting. But I absolutely love the dynamics. As the company is growing so fast, there are so much to do. An employee can go out there and challenge themselves as much as they want. The hierarchy is flat. You can reach out to everyone and they will listen to you. Even as an intern, I had the opportunity to work with two senior managers. Jensen Huang once offered me a beer. My experience is far from unique. Also, Jensen Huang is the coolest CEO ever. His style is fire (leather jacket yo) and he has a wicked sense of humor. He invited all interns to his house for an end of summer party and everyone loved him. It takes a cool CEO to build a cool company. 2. The workNVIDIA is known for hardware, but they also have a strong software engineering team. My manager lets me choose what I want to work on. The work ranges from research to large-scale production, so there are plenty of projects for me to choose from. My work is not restricted to a tiny piece of code, and I can be the owner of a project. I can also work with people from other teams. Once, I was impressed with someone’s work and he was on another team. I reached out to him and we did a project together. I realized that I loved my work at NVIDIA when one Saturday, I suddenly had the urge to come to the office to finish some experiments. I have never felt bored at work. There is always something to work on or someone to talk to. I’m learning so much. 3. The impactUnlikely many big companies, NVIDIA managers share the company’s strategy with their staff. Even as a low-level engineer, I feel like I know where the company is headed. NVIDIA is ambitious. They offer many projects with huge potential. I can make a difference with the project I’m working on. The managers watch out for your work and make sure they get the attention they deserve. I once volunteered to do something for the company and my work got detailed feedback from one VP and two senior directors. This is unlikely to happen at other big companies. 4. The fightThe hardware competition is red hot right now. Every tech giant seems to want to a piece of it. Working at NVIDIA gives me a front-row seat to watch it unfold. When I asked my manager why he moved here from Apple, he said it’s because of “the fight”. For some reason I haven’t been able to internalize, being part of NVIDIA seems heroic. I want to do my best to help NVIDIA win the fight. Some people might ask: what about the pay? Did money really not factor in my thought process at all? It’d be a lie to say I wasn’t tempted when someone mentioned their 6-figure sign on bonus fresh out of their master’s program. Like many of peers, I have the goal of one day having enough money to never have to work for money. But for now, working in tech, I know that whatever job I choose will probably pay me well enough. I believe that if I opt for personal growth, one day, I will have a set of skills desirable enough to make more money than I care to spend. Youth is too precious to be sold for money. General advice Know what you’re optimizing for: money, new experiences, prestige, personal growth, or something else? If you don’t know what you want to do, pay attention to what you do in your free time. It’s what you do when nobody is watching that shows your true interests. At least for AI, the line between industry and academia is getting blurrier and blurrier. Don’t fret about PhD or no PhD. You can always start your PhD and then drop out, or apply for a PhD after a few years in industry. Publish your code on GitHub and invest your time to build some decent GitHub repos. I’ve had more than one company that offered me a job because they were impressed with my GitHub. Don’t freak out about your GPA. If you think it’s low (e.g. &lt; 3.3), just don’t put it on your resume. As long as you have a decent technical background (e.g. past internships + side projects + GitHub), nobody cares about your GPA. During college, intern at both big companies and startups to get a sense of what kind of organization you want to join. The easiest kind of offer you can aim for is an intern-to-full-time conversion offer. The intern interview process can be 3x easier than a full-time interview process. Start your job search early, preferably at the beginning of your senior year. Most of my friends get their full-time offers 2-3 quarters in advance. Early job offers give you peace of mind to be yourself in interviews and leverage to negotiate later. Don’t give up just because you haven’t heard back from some companies. I know people who sent their resumes to hundreds of companies until they got a job. Technical interviews are a pain. Prepare for them a least a month in advance. During interviews, ask about the kind of tasks you’ll do in the role, the manager you’ll report to, and the kind of mentorship you’ll get. Don’t shy away from negotiation. Even if you don’t work for money, you have every right to be paid your worth. In my experience, companies always match offers, even if they say they don’t. I’ve seen two friends with similar experience joining the same company for the same role, but one got $50k more a year because he had a competitive offer. Ask people you admire for their experiences and career advice. Read Glassdoor reviews to get a sense of what you’re getting yourself into. Take some time off between college and your first full-time job, as it’s unlikely you’ll have a vacation again for a long time. If the only reason you stay in a job is the pay, leave. If you don’t find yourself learning in a job, leave. Resist the rat race. Stop comparing yourself to other people. No matter how good you are, there will always be someone who’s better than you at something. Instead, compare you of today with you of yesterday. Be nice. Be kind to yourself. You don’t have to graduate at xx, get a PhD when you’re xx, or become a millionaire when you’re xx. Discover the world. Get to know yourself. Enjoy the process. AcknowledgementsThis post wouldn’t have been possible without long conversations over the year with many people I admire, in both industry and academia. I’d like to thank Christopher Manning, Mykel Kochenderfer, Alexander Rush, Lukasz Kaiser, Laurence Moroney, Danijar Hafner, Lucas Baker, Paul Warren, Jonathan Cohen, Boris Ginsburg, Rex Garland, David Buickians, Dung Ho Chi, and many other friends for putting up with my indecisiveness and unclogging my impossibly dense mind. P/S: If this post makes you interested in learning more about working at NVIDIA, shoot me an email!","link":"/2019/05/26/给最近计算机科学毕业生的职业生涯建议/"}],"tags":[{"name":"point cloud","slug":"point-cloud","link":"/tags/point-cloud/"},{"name":"pointnet","slug":"pointnet","link":"/tags/pointnet/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"学习计划","slug":"学习计划","link":"/tags/学习计划/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hackathon","slug":"hackathon","link":"/tags/hackathon/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"keyboard accelerators","slug":"keyboard-accelerators","link":"/tags/keyboard-accelerators/"},{"name":"computer graphics","slug":"computer-graphics","link":"/tags/computer-graphics/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"presentation","slug":"presentation","link":"/tags/presentation/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"caffe","slug":"caffe","link":"/tags/caffe/"},{"name":"matlab","slug":"matlab","link":"/tags/matlab/"},{"name":"stylus","slug":"stylus","link":"/tags/stylus/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"面向对象","slug":"面向对象","link":"/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"talk","slug":"talk","link":"/tags/talk/"},{"name":"life","slug":"life","link":"/tags/life/"}],"categories":[{"name":"point cloud","slug":"point-cloud","link":"/categories/point-cloud/"},{"name":"学习计划","slug":"学习计划","link":"/categories/学习计划/"},{"name":"ejs","slug":"ejs","link":"/categories/ejs/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"hachathon","slug":"hachathon","link":"/categories/hachathon/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"keyboard accelerators","slug":"keyboard-accelerators","link":"/categories/keyboard-accelerators/"},{"name":"computer graphics","slug":"computer-graphics","link":"/categories/computer-graphics/"},{"name":"presentation","slug":"presentation","link":"/categories/presentation/"},{"name":"process","slug":"process","link":"/categories/process/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"icarus","slug":"icarus","link":"/categories/icarus/"},{"name":"caffe","slug":"caffe","link":"/categories/caffe/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"talk","slug":"talk","link":"/categories/talk/"},{"name":"life","slug":"life","link":"/categories/life/"}]}