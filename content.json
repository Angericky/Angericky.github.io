{"pages":[{"title":"关于我","text":"你好，这里是一枚非典型工科生，是硬核且甜甜软软的妹子。在NVIDIA实习中，在成为software engineer的路上挣扎。我喜欢很多领域，音乐剧 / 设计 / 漫画 / 文学，也欢迎安利呀。 教育经历 硕士 software engineer 华东师范大学研究方向：computer vision2019年入学 本科 computer science 华东师范大学2015年入学 感兴趣的专业技能 机器视觉和图像处理 Deep Learning C++ Web 对自己读研的期望是能成为工程能力很强的researcher～加油！ 联系我 在blog留言 QQ: 707767931 Wechat: Angericky Email: jingjingbudlet@gmail.com / presente_de_deus@163.com 涉足无人抵达的远方就能摘取星星上的金子。","link":"/about/index.html"},{"title":"设计集collection","text":"大学时期制作的海报找不太到了，放上追星途上为爱发电的一些拙劣之作，也算是纪念年少青春的闲暇时光～这辈子的水平大概也就止于对优秀的平面设计作品欣赏啦。","link":"/collection/index.html"}],"posts":[{"title":"C++开发学习计划","text":"这一年，领悟到无论是出国/保研/考研/就业的道路，我们都应该拓宽横向比较的世界，不局限在身边的人，要去看更多优秀的人是怎么做的，这种借鉴能让我避免处在井底之蛙的境地，对信息搜集和个人成长都大有益处。时光无法补救，已经蹉跎到大四了，既然意识到积累太少，就更应该补上专业方面的知识，将书读薄再读厚。 前言即将踏入2019年实习阶段。在面试了几次才知道自己有多菜，但每一次面试都会发现自己的不足，可以有针对性地查漏补缺，因此有面试经历真是很棒。 发现如果早点开始做就业准备，一定可以拿到比较喜欢的offer，而我的大三大四就不会显得这么被动，以至于往读研方向发展没有退路。 成绩好就是学习好的认识太狭隘了。说课业紧张而不去实习，其实是自我管理和学习效率不够，时间是海绵里的水，挤挤总是有的。 这一年，领悟到无论是保研还是就业的道路，我都应该拓宽横向比较的世界，不局限在身边的人，要去看更多优秀的人是怎么做的，这种借鉴能让我避免处在井底之蛙的境地，对信息搜集和个人成长都大有益处。 时光无法补救，已经蹉跎到大四了，既然意识到积累太少，就更应该补上专业方面的知识，将书读薄再读厚。 需要读的书/掌握的知识C++ Effective C++ More Effective C++ STL源码解析 对象模型 C++ Primer Plus C++ Primer 操作系统 操作系统概论 现代计算机操作系统（这本书是讲操作系统的 深入理解计算机操作系统（这本书是讲程序在操作系统中处理的） 计算机网络 计算机网络第六版谢仁希 tcp/ip详解 数据结构 哈希表实现，冲突解决方法 AVL树、红黑树 哈夫曼编码 算法 常用排序算法、复杂度计算、查找、DFS、BFS 记忆化搜索、DP 最短路算法 字符串相关的(如：KMP、BM等）。 线段树 编译原理 DFA、NFA 解决二义性的方法 解决移进/规约冲突 设计模式 大话设计模式 设计模式解析第二版 每个设计模式做小demo并备份 暂时就列这些，利用上班通勤和其他碎片时间慢慢读～","link":"/2018/12/26/C-开发学习计划/"},{"title":"EJS里判断一个变量是否可用","text":"改博客时候遇到的问题：ejs互相传参数，怎么得知参数有没有被传呢？ 问题描述node代码里存在两种情况：12res.render(&apos;home/content&apos;, { detail:detail,list:list } );res.render(&apos;home/content&apos;, { detail:detail } ); EJS:123&lt;% if(list==undefined){ %&gt; &lt;span&gt;暂时没有内容&lt;/span&gt;&lt;% } %&gt; 当node里不提供list的时候，页面判断list是否存在的时候报错12345678ReferenceError: D:\\demo\\views\\home\\content.ejs:10 8| &lt;/div&gt; 9| &lt;/div&gt;&gt;&gt; 10| &lt;% 11| if(list==undefined){ 12| 13| }list is not defined 这时候怎么办？难道必须在node里添加一个list为空的变量过来吗？还是有在EJS里有其他验证方法？ 解决方法123if(locals.list==undefined){ ...} 用到EJS的locals就可以防止报错啦～","link":"/2019/01/12/EJS里判断一个变量是否可用/"},{"title":"Vue学习总结","text":"xmind + 笔记，整理细碎的知识点。 Vue.js是什么Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。需要理解的是，Vue的一个核心思想是数据驱动，组件与组件之间只有数据交换。对于视图的修改，不会直接操作DOM，而是通过修改数据。交互复杂时，只关心数据修改会让代码逻辑变得很清晰，不用碰触DOM，这样的代码非常利于维护。 Vue知识体系这是我自己根据官方文档在思维导图上构建的知识体系。 生命周期什么是生命周期 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册js方法，可以让我们用自己注册的js方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。 生命周期图及标注 特别值得注意的是created钩子函数和mounted钩子函数的区别 生命周期钩子函数beforeCreate 在实例初始化后，数据观测(data observer)和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下配置：数据观测(data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的render函数首次被调用。 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。 beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vuex是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。","link":"/2019/03/10/Vue学习总结/"},{"title":"gitlab与github","text":"两者都是用git实现代码托管的版本仓库，两者很相似，那它们的区别是？ 简介相比于GitHub，GitLab更适合企业级使用，为企业搭建GitLab软件版本管理服务器。 GitLab：https://about.gitlab.com/GitHub: https://github.com/ GitLab利用Ruby on Rail开发的开源应用程序，实现一个自托管的Git项目仓库，可以通过web界面进行访问公开的或者私人项目。Ruby on Rail是一个使你开发、部署、维护web应用程序变得简单的框架。GitLab拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释，可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库，它提供一个代码片段功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub。 两者区别相同点二者都是基于web的Git仓库，在很大程度上GitLab是仿造GitHub来做的，他们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。 不同点： GitHub如果使用私有仓库，是需要付费的，GitLab可以在上面搭建私人的免费仓库 GitLab让开发团队对他们的代码仓库拥有更多的控制，相对于GitHub，它有不少的特色： 允许免费设置仓库权限 允许用户选择分享一个project的部分代码 允许用户设置project的获取权限，进一步提升安全性 可以设置获取到团队整体的改进进度 通过innersourcing让不在权限范围内的人访问不到该资源 gitlab安装及使用： 关闭防火墙和selinux，并安装安装依赖的包 12345systemctl stop firewalld &amp;&amp; systemctl disable firewalldsetenforce 0 并修改/etc/selinux/config yum -y install openssh-server postfix yum install -y curl policycoreutils-python openssh-server 启动positfix和sshd 12systemctl enable postfix &amp;&amp; systemctl start postfixsystemctl enable sshd &amp;&amp; systemctl start sshd 下载安装包并安装安装包 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash 打开/etc/gitlab/gitlab.rb,将external_url = 'http://git.example.com'修改为自己的IP地址：http://xxx.xx.xxx.xx,然后执行下面的命令，对GitLab进行编译。 sudo gitlab-ctl reconfigure 登录GitLab Username: root Password: 5iveL!fe GitLab管理 gitlab-ctl start/stop/restart/reconfigure git相关概念： git 是一种版本控制系统，是一个命令，是一种工具 gitlib 是基于git功能的开发库 github 是一个基于git实现在线代码托管的仓库，包含一个网站界面，向互联网开放 gitlab 是一个基于git实现的在线代码仓库托管软件，一般用于在企业内搭建git私服git-ce是社区版，gitlab-ee是企业版，收费版","link":"/2019/02/22/gitlab与github/"},{"title":"git修改已提交的备注","text":"用rebase修改github上历史修改的备注。 最后一次提交的注释1git commit --amend 然后在出来的编辑界面，直接编辑注释的信息,保存退出。 更早之前的历史修改假设要修改当前版本往前三次版本的状态,四次就把HEAD~3改成HEAD~4,以此类推/1git rebase -i HEAD~3 假设要从第一个版本开始修改，1git rebase -i --root 然后会看到，123pick sha1 Xpick sha1 Ypick sha1 Z 要修改哪个,就把那行的pick改成edit，123pick sha1 Xedit sha1 Ypick sha1 Z :wq保存并退出。通过git log查看历史，可以发现git的最后一次提交已经变成刚才选的那个了然后就和修改最后一次提交一样了1git commit -amend 修改完了之后,这样返回1git rebase --continue 这时候就又回到正常状态了 压缩掉不需要的版本和上面一个修改历史差不多，也是使用git rebase同样会看到123pick sha1 Xpick sha1 Ypick sha1 Z 不同的是要压缩掉哪个版本,就把那个版本pick改成squash123pick sha1 Xsquash sha1 Ypick sha1 Z 保存退出,会出现备注,再次保存退出。用git log查看那个备注为Y的版本已经没了。","link":"/2019/01/02/git修改已提交的备注/"},{"title":"Google Girl Hackathon 2019赛后感","text":"很幸运拿到了Dream Company这次girl hackathon的门票。在周五到周末三天的小组团队项目比赛里，我们组DeliveryGo拿到了Best Team Top 2，很开心～ 2019年，分别到了我最喜欢的软件和硬件公司体验了一下，非常幸运。 Google Shanghai的地理位置也太好了吧，居然在环球金融中心，左拥金茂大厦，右抱东方明珠。不过陆家嘴上下班时间有点挤。Google Shanghai的食堂还不错，是自助餐式的，如果天天在这里吃这种健康的食物，我一定会变瘦的。周末给我们订的外卖也不错，准备的零食也很充分，抹茶糯米团真好吃。 HR小哥哥Brett的酒窝好甜哦！呜呜呜，过去social发现是校友，真好。逛了一圈office，发现工位没有我们NVIDIA的大（骄傲脸）。（对不起，主题跑偏了） 这次girl hackathon的项目里，我和本系学妹以及浙大的三个姑娘组成了一个五人团队，根据题目起的队名叫DeliveryGo（模仿alphaGo），另外几个妹子主要看算法，只有我懂一点JS，所以只好挑起做前端的大梁啦。 我主要做了web的路径规划可视化，已经放到我github的repository里了，UI挺好看的，也感谢队友们一起设计、找图和PS的努力。 48小时里写出来这样的demo，我发现自己的学习速度超乎预期，没想到能写这么快，看来在NV实习的一个月的成长还是挺快的，不仅是关于前端的知识，还有自学的能力。我对自己更有信心了。 从算法结果、Demo、pre三方面打分，最后我们拿到了Best team top 2。是很棒的结果，谢谢队友们的共同努力，前一天通宵的努力是有收获的。 没拿到Best team top one，挺可惜的，可能是因为操作失误，我们组的算法结果交错了几组，没拿到最好的performance and efficiency。Presentation展示Demo的时候，也有其他组做了的UI很好。有点难过，这种不甘心大概也能更好地驱动我继续学习，努力向前走吧。 谢谢nowcoder以及Google提供的这次机会，我是一个容易被鼓励但会很轻易怀疑自己的人，这个活动对我的激励真的很大。 (顺带一提，google奖品里给的包真的很不错，这个安卓机器人模型也很可爱！) 有点后遗症，由于长时间盯着电脑，肩膀和脖子不舒服了两三天，做这行还是要多健身多运动呀～","link":"/2019/03/18/google-girl-hackthon-2019赛后感/"},{"title":"O(n)算法查找第k大的数","text":"面试中常见的经典算法题：O(n)算法查找第k大的数。 O(n)算法查找第k大的数思路这里讲利用快速排序Partion的算法，核心思想是快排的分支算法，具体思路： 利用快排的partion函数将数组分成左右两个部分 如果位置p刚好等于k，则说明p位置的数，就是我们要找的数，如果分出来的边界位置p小于给定的数k，我们知道最小的第k个数，肯定在p的右边，如果p大于给定的k则在p边界的左边 递归在p的左边或者右边查找 注：p为数组下标需要加1。 具体的细节可以查看《算法导论》第九章，下面是简单的实现代码。 复杂度对于快速排序，算法复杂度是O(N * logN)。而这个算法的算法复杂度是O(N)。为什么呢？其实这个地方的算法复杂度分析很有意思。 第一次交换，算法复杂度为O(N)，接下来的过程和快速排序不同，快速排序是要继续处理两边的数据，再合并，合并操作的算法复杂度是O(1)，于是总的算法复杂度是O(N * logN)（可以这么理解，每次交换用了N，一共logN次）。 但是这里在确定枢纽元的相对位置（在K的左边或者右边）之后不用再对剩下的一半进行处理。也就是说第二次插入的算法复杂度不再是O(N)而是O(N/2)。？接下来的过程是1+1/2+1/4+…….. &lt; 2，换句话说就是一共是O(2N)的算法复杂度也就是O(N)的算法复杂度。 代码递归实现123456789101112131415161718192021class Solution {public: int partion(vector&lt;int&gt; &amp;nums,int k,int start, int end){ int tmp = nums[start], n = nums.size(), left = start, right = end; while(left &lt; right){ while(right &gt; left &amp;&amp; nums[right] &lt; tmp) right --; if(right &gt; left) nums[left ++] = nums[right]; while(left &lt; right &amp;&amp; nums[left] &gt;= tmp) left ++; if(left &lt; right) nums[right --] = nums[left]; } nums[left] = tmp; if(left == k - 1) return tmp; else if(left &gt; k - 1) return partion(nums, k, start, left - 1); else return partion(nums, k, left + 1, end); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { return partion(nums, k, 0, nums.size() - 1); }}; 非递归实现12345678910111213141516171819202122232425262728293031static auto sycn_false = [](){ ios :: sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int start = 0, end = nums.size() - 1; while(start &lt;= end){ int tmp = nums[start], left = start, right = end; while(left &lt; right){ while(left &lt; right &amp;&amp; nums[right] &lt; tmp) right --; if(left &lt; right){ nums[left ++] = nums[right]; } while(left &lt; right &amp;&amp; nums[left] &gt;= tmp) left ++; if(left &lt; right){ nums[right --] = nums[left]; } } nums[left] = tmp; if(left == k - 1) return nums[left]; else if(left &gt; k - 1) end = left - 1; else start = left + 1; } return -1; }};","link":"/2018/12/26/O-n-算法查找第k大的数/"},{"title":"网页的跳转页面及参数传递方法","text":"两者都是用git实现代码托管的版本仓库，两者很相似，那它们的区别是？ 跳转页面 直接在跳转的内容外部加上 html加参数onclick=”function()”function里写window.open(&quot;url&quot;, _self/__blank(default);或者 12window.location.href=&quot;url&quot;;window.history.back(-1); 参数传递： url传参：第一个页面(a.html)： 1234var obj = a.value; //传给弹出页面参数var url = &apos;jxb.html?obj=&apos;+obj;url = encodeURI(url);window.open(url, &quot;&quot;, &quot;width=600,height=400&quot;); 第二个页面(b.html)： 1234var url = decodeURI(window.location.href);var argsIndex = url .split(&quot;?obj=&quot;);var arg = argsIndex[1]; 注:中文传输:可以在页面a用encodeURI 编码url 在b页面用decodeURI解码url cookie传参(不能跨域)： 1234567function setCookie(cname,cvalue){ document.cookie = cname + &quot;=&quot; + cvalue;}function getCookie(cname){ var name = cname + &quot;=&quot;; var ca = document.cookie;}` localStorage对象传参： 1234567a.html：var div = doucment.getElementById(&apos;要获取字符串的DIV ID名&apos;);localStorage.string = div.textContent;b.html：var div = doucment.getElementById(&apos;要写入的DIV ID名&apos;);div.textContent = localStorage.string; window.opener() 父页面： 12&lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot;/&gt;window.open(&quot;子页面.html&quot;); 子页面： 1window.opener.document.getElementByIdx(&apos;textfield&apos;).value=&apos;123123123&apos;; 如果跨域，子页面还要加上document.domain=”父页面url”","link":"/2019/03/05/html跳转页面的参数传递/"},{"title":"Hello World","text":"This is jingjing’s very first post. There is some information about hexo. Welcome to Hexo! This is jingjing’s very first post.Hello world~Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/12/22/hello-world/"},{"title":"深度学习在3D点云处理中的探索【笔记】","text":"bilibili上刘永成博士的分享课的笔记记录。 Introduction multi-view images + 2D CNN2D CNN对多视角图像进行学习和信息综合，恢复3D shape缺点：拍摄自遮挡，3D信息损失 volumetric data + 3D CNNCAD model进行3D Grid的划分缺点：grid划分太粗，形状信息损失；划分太精细，复杂度非常高 mesh data（网格数据） + DL(GNN)? ——刚起步的阶段，需要探究 深度图 + CNN point cloud + DL（GNN &amp; CNN）？ point cloudraw sensor data 直接可以得到 (激光雷达)simple representation(N*(x, y, z, color, normal))better 3D shape capturing 应用领域：自动驾驶、AR&amp;VR、机器人、遥感图像、3D人脸&amp;医学、3D游戏动画的形状设计、e.g. 目前需要思考的问题：如何更有效、更快速地处理点云？不规则点云怎么做深度学习/神经网络（进行研究） datasets:简单的model: Princeton ModelNet: 1k个点 ShapeNet Part: 2k个点 PartNet models: (CVPR 2019)(数据集刚提出来，考虑精度提高) 层次化语义分割标注，coarse -&gt; fine-grained 面向使用的复杂的model: Stanford 3D indoor scene: 8k个点 Semantic 3D: 4 billion in total ScanNet（室内场景）: seg + det检测 自动驾驶类：KITTI, nuScenes: det检测 挑战和难点： 不规则，无序。输入顺序不同，卷积结果会发生变化。需要建立置换排列不变性 刚性变换的鲁棒性(robustness to rigid transformations)：naive的toy点云 对于点云的corruption, outlier noise的鲁棒性; partial data局部数据；large-scale data保持高效 Brief reviewpointnet家族共享多层感知机(Shared MLP) + max pool（内部数据发生置换，结果不会发生改变）逐级映射到高层表示刚体变换（包括平移、旋转、反转）: 增加T-net(transform net)， 将输入的三维点云进行变形，得到规范的数据，能够映射到高维卷积神经网络：由局部到全局的学习范式PointNet++ 捕捉局部模式显式地模仿CNN输入点云采样一些点，以这些点作为中心，寻找局部邻域 规整化处理 分成3D grid，对每个grid做PointNet + 3D CNN（VoxelNet, CVPR 2018） lattice映射到晶格网络+bilateral convolution双边卷积+hash index（SPLATNet, CVPR 2018） 原始点云映射到体积空间，没有任何离散或者近似（PCNN, SIGGRAPH 2018） 直接学习，卡方矩阵学习变换(PointCNN, NIPS 2018)加权和置换，simultaneously weight and permute the input features 方向编码+尺度敏感(PointSIFT, CVPR 2018)对每一个领域，找邻居点，建立坐标系八个象限，进行方向卷积（orientation-encoding）参考深度学习的思想，concat多层特征，端到端找到最合适的尺度(scale-aware) (Self-Organizing Map)自组织映射+MLP( SO-Net, CVPR 2018)在空间里用Self-organizing点，拟合了geometry structure，学习后能够capture到映射，用了Kd-Tree Pointwise CNN(CVPR 2018)简单暴力，直接用3x3的网格，求和+归一化，当作一个特征去卷积 (一篇比较早的文章，影响比较大，比较独树一帜) Kd-Net, ICCV 2017用Kd-Tree对原始点云做划分，通过变换的学习到达根节点。将数据结构用到点云分割里。 FCPN, ECCV 2018模仿2D空间的FCN，用3D grid, 用pointnet学习每个grid的low-level特征，再用3D CNN做分割可以一次性处理200k个点 graph-based modeling DGCNN, TOG 2019提出边缘卷积EdgeConv，不卷积点，卷积点与点之间的边用邻居点和特征差进行权重学习，得到卷积结果 Regularized GCNN. MM 2018图卷积 用拉普拉斯矩阵 正则化，kNN思想 GAN for Point Cloud. ICLR 2019用point cloud的格式做gan需要学习图结构 Spectral Graph Convolution. ECCV 2018在谱域进行学习spectral graph conv谱聚类 + recursive spectral cluster pooling Superpoint Graph, CVPR 2018minimal partition(最优化的解决方案) + GCN（边缘条件卷积）用邻边建立superpoint graph作者在CVPR 2019提出了Oversegmentation做superpoint graph Deep GCNs. ICCV 2019探究能不能把graph的网络做深残差结构、膨胀卷积是否有用 convolution kernel 卷积有效性 KC-Net. CVPR 2018用点云配准的学习思想增加kernel correlation（核相关） KPConv. arXiv 2019用了一个带权重的点集kernel points类比2D kernel，输入点云和kernel points里面的每一个点的权重矩阵相乘，然后通过一个相关系数加权求和。 MCCNN. TOG 2018蒙特卡洛卷积。使用蒙特卡洛公式离散化（引进密度） PointConv. CVPR 2019 Geo-CNN. CVPR 2019引入角度，更好地学习局部几何","link":"/2019/09/17/【笔记】深度学习在3D点云处理中的探索/"},{"title":"vue-router传递参数params和query的区别","text":"如题。 比较用法1. 用法query要用path来引入，params要用name来引入(当你使用params方法传参的时候，要在路由后面加参数名)，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。如果传参时未定义name，则获取不到params。 路由界面1234567&lt;router-link :to=\"{ name: 'router1', path: 'Hello', params: { id: 'menuIndex' }, query: { id: 'menuIndex' } }\"&gt;&lt;button&gt;Go to Foo&lt;/button&gt;&lt;/router-link&gt; 2. url地址显示query更加类似于我们ajax中get传参，params则类似于post，说得简单一些，即前者在浏览器地址栏中显示参数，后者则不显示。 queryhttp://localhost:8080/workorder/newApply?type=BOX_DEPLOY&amp;typeDesc=%E5%B0%8F%E7%99%BD%E7%9B%92%E9%83%A8%E7%BD%B2 paramshttp://localhost:8080/workorder/newApply 3. 注意点query刷新不会丢失query里面的数据params刷新会丢失params里面的数据","link":"/2019/03/03/vue-router传递参数params和query的区别/"},{"title":"常用快捷键和指令","text":"包括但不限于vim和Linux命令。 网页开发者工具 打开/关闭chrome + safari mac: opt + command + i win: F12 ctrl + shift + i/j 截屏快捷键 mac: command + shift + 3，全屏自动保存到桌面 command + shift + 4，鼠标框选需要截图的地方，自动保存到桌面 space键可以移动这个区域 shift键可以锁定x/y轴进行拖动 option键能按照区域圆心进行放大 win: Win + Shift+ S， 截图自动保存到剪贴板 Vim12345678910111213141516171819202122232425262728293031ctrl + f # 屏幕『向下』移动一页ctrl + b # 屏幕『向上』移动一页n + [space](n为数字，space空格键) # 按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20[space] 则光标会向后面移动 20 个字符距离。0 # 这是数字『 0 』：移动到这一行的最前面字符处$ # 移动到这一行的最后面字符处G # 移动到这个档案的最后一行nG # n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行n + [Enter] # n 为数字。光标向下移动 n 行dd # 删除游标所在的那一整行ndd # n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行yy # 复制游标所在的那一行nyy # n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行set nu # 设置显示行号set nonu # 设置不显示行号ctrl + z #最小化fg # 恢复最小化 Linux命令 df 显示磁盘统计空间12345678df -h文件系统 容量 已用 可用 已用% 挂载点/dev/vda1 40G 5.3G 32G 15% /devtmpfs 909M 0 909M 0% /devtmpfs 920M 0 920M 0% /dev/shmtmpfs 920M 444K 919M 1% /runtmpfs 920M 0 920M 0% /sys/fs/cgrouptmpfs 184M 0 184M 0% /run/user/0 du 显示当前目录下文件夹大小du -h –maxdepth=11234567891011232K ./scripts55M ./src12K ./distribute13M ./lib952K ./CMakeFiles19M ./install176K ./cmake4.0K ./test580K ./docs2.7M ./tools5.8M ./python free 于显示内存状态1234free -mtotal used free shared buff/cache availableMem: 1838 265 981 0 591 1395Swap: 2047 0 20 查看linux ip地址 ip addr show | grep inet | awk ‘{ print $2; }’ | sed ‘s/\\/.*$//‘ find命令查找最近修改过的文件 按时间查找也有参数 -atime 访问时间 -ctime 改变状态的时间 -mtime修改的时间。但要注意，这里的时间是以24小时为单位的。查看man手册后使用，你会很迷惑： -mtime n： Files data was last modified n*24 hours ago. 字面上的理解是最后一次修改发生在n个24小时以前的文件，但实际上 12find ./ -mtime 0：返回最近24小时内修改过的文件。find ./ -mtime 1 ： 返回的是前48~24小时修改过的文件。而不是48小时以内修改过的文件。 那怎么返回10天内修改过的文件？find还可以支持表达式关系运算，所以可以把最近几天的数据一天天的加起来： ./ -mtime 0 -o -mtime 1 -o -mtime 2 ……```123456789 另外， -mmin参数-cmin / - amin也是类似的。# win打开我的电脑 Win + E# vscode - 打开terminal ```ctrl+`","link":"/2019/02/22/常用快捷键/"},{"title":"华东师范大学优秀毕业生答辩稿","text":"2019.4.8，优秀毕业生答辩稿。 &emsp;&emsp;亲爱的老师、同学们，我是来自计算机系的学生赵菁菁。&emsp;&emsp;今天想和大家分享一下我作为一名计算机的学生，在华师大三年半以来的学习经历。首先按惯例是做个简单的自我介绍。 &emsp;&emsp;目前是大四学生，大学完成度90%，保研到本校马利庄老师的多媒体和计算机视觉实验室，同时也在NVIDIA半导体科技公司做开发实习生。 &emsp;&emsp;我兴趣广泛，什么都喜欢尝试一下。所以这四年我的生长脉络是一颗自由生长的乱点技能点的树。&emsp;&emsp;前两年做过一些Web相关的项目，JS MySQL PHP Python什么语言都用过。&emsp;&emsp;出于对设计的兴趣也很好奇计算机视觉的研究，和朋友折腾了一个基于yolov3框架的目标检测项目，对应用在cv领域的深度学习有了初步了解&emsp;&emsp;平时在维护、改进个人博客和我的github（期待拥有一面绿墙），阅读技术分享和其他大学的计算机在线课程。业余时间会去看音乐剧、唱唱歌或者做点美工。 &emsp;&emsp;我的学生工作经历里，就业创业服务工作室是很重要的一段。在这里我结识了不同专业的同学和老师，学到了做一件事就追求做到最好的精神，大家为着同一个目标充满热情地设计、安排活动、联系嘉宾，讨论可行方案，努力改进每一次活动。&emsp;&emsp;任职期间，我参与组织过年度毕业生大型秋季招聘会、精英训练营、华师创业说品牌活动、挑战杯活动等。我和上届下届的部门伙伴现在也是很好的朋友，经常聚餐。&emsp;&emsp;除此之外，在团学联文艺部和科创团委，我点亮了美工设计的技能点；在合唱团，我向艺术特长生学习，提升了视唱水平和艺术修养，参加各种电视台的演出；社会实践部分，我们小团队走访了不少IT相关的公司，给大一新生们做了一份有趣的职业指南手册。 &emsp;&emsp;描述我的本科生涯，一半是“做什么都是因为喜欢”，另一半是“弱水三千，我愿只取一瓢”。&emsp;&emsp;命运指使我读计算机专业，可能是它给我这辈子安排的最棒的事。&emsp;&emsp;大学前两年的我对专业不抱有太大的热情，只是觉得数据结构和算法还挺有意思的，但即使编程实践第一次考试就拿了优，也因为觉得自己基础不好，畏头畏尾没参加ACM队的选拔。&emsp;&emsp;结果后来真香定律愈演愈烈。我发现随着知识积累，对现象的思考和观察事物的层次也会渐渐不一样。 &emsp;&emsp;学习的过程中有过自我质疑，甚至痛苦，但回想这四年，即使为了大作业或者项目熬夜通宵，也还是很快乐，我的发际线也可以再拼一下。 &emsp;&emsp;我剖析了一下自己喜欢计算机的理由。&emsp;&emsp;我喜欢数学和逻辑思维，并且痴迷于解决实际生活的问题，喜欢严谨和抽象化的思维方式。我乐于源源不断扩充并学习新的技术，也喜欢程序员自黑的幽默感。 &emsp;&emsp;在学习开发和人工智能的过程中，我越来越觉得以前认为的枯燥的计算机体系结构、高性能计算、分布式架构等越来越有趣。这些底层知识不会过时，而且它们就像力学之于建筑的地位，牢牢地撑起顶端枝叶的快速生长。不懂的话，干活是能干，但设计的时候可能想不到一些潜在的问题，而给以后带来无穷无尽的麻烦。所以我最近在业余时间也在回顾和巩固这些领域的内容。&emsp;&emsp;我相信花时间去学习新的知识，新的技能，都不会浪费时间，可能就在某天某个机遇下，就会发现自己学过看起来无用的东西，有用。 &emsp;&emsp;很荣幸今天大家坐在下面，听我絮絮叨叨讲了这么多自己学习的经历，谢谢大家。","link":"/2019/04/08/华东师范大学优秀毕业生答辩稿/"},{"title":"扔鸡蛋问题","text":"Leetcode 887 Super Egg Drop. DP问题 题目描述：你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。你的目标是确切地知道 F 的值是多少。无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例1: 输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。 示例2: 输入：K = 2, N = 6输出：3 示例3: 输入：K = 3, N = 14输出：4 提示: 1 &lt;= K &lt;= 100 1 &lt;= N &lt;= 10000 解决思路：这个题目乍一看能暴力解决，然而仔细想想就会发现是需要用dp才能求出最优解的。 问题f(N)，表示1～N层。假设有两个鸡蛋，从F层往下扔，会出现两种情况： 碎了，F - 1次， 没碎，还有N - F层，可以试两个鸡蛋，转化为子问题f(N - F) 推广之后，用f(K, N), K表示鸡蛋的个数，N表示楼层有N层。 当第一个鸡蛋从第F层扔下的时候，会得到两种结果： 如果碎了，还剩K - 1个鸡蛋，有F - 1层楼层需要扔，问题转化成f(K - 1, F - 1) 如果没碎，还剩K个鸡蛋，有N - F个楼层需要扔， 问题转化成f(K , N - F) 可得状态转移方程f(K, N) = min( 1 + max( f(K - 1, F - 1), f(K, N - F) ) ) 推出代码：123456789101112131415161718192021const int MAXK = 100, MAXN = 100;int max(int a, int b) {return a &gt; b ? a : b;}int min(int a, int b) {return a &lt; b ? a : b;}int superEggDrop(int K, int N) { int dp[MAXN+2][MAXK+2]; for (int i = 0; i &lt;= MAXN; i++) { dp[i][0] = 0; dp[i][1] = i; } for (int j = 2; j &lt;= MAXK; j++) { for (int i = 1; i &lt;= MAXN; i++) { dp[i][j] = i; for (int k = 1; k &lt; i; k++) { dp[i][j] = min(dp[i][j], max(dp[k-1][j-1], dp[i-k][j]) + 1); } } } return dp[N][K];} 用这个办法做出来TLE，怎么办呢？我们可以改变一下求解的思路，求k个鸡蛋在m步内可以测出多少层。 f(K, M)，表示K个鸡蛋在M步内，最坏条件下能测出的层数。假设一共有K个鸡蛋，最多能扔N层。从F层扔下鸡蛋，会出现两种情况： 碎了，剩下K - 1个鸡蛋和M - 1步，f(K - 1, M - 1) 没碎，剩下K个鸡蛋和M - 1步，f(K, M - 1)因此f(K, M) = f(K - 1, M - 1)(摔碎时能确定的层数) + f(K, M - 1)（没摔碎时能确定的层数） + 1（本层）考虑边界情况： 没有鸡蛋，一层都测不出来。可得f(K, 0) = 0 只有一个鸡蛋，那必须从第1层开始扔，最坏情况要扔到M层才能测出来，一共扔M次。可得f(1, M) = M 推出代码：12345678910111213141516class Solution {public: int superEggDrop(int K, int N) { if(K == 1) return N; int dp[10001][101] = {0}; for(int m = 1; m &lt;= N; m ++){ for(int k = 1; k &lt;= K; k ++){ dp[m][k] = dp[m - 1][k] + dp[m - 1][k - 1] + 1; if(dp[m][k] &gt;= N) return m; } } return N; }};","link":"/2019/05/08/扔鸡蛋问题/"},{"title":"用Supervisor管理进程、监控程序","text":"Supervisor是一个很棒的进程管理工具，能够监听进程重新启动，不需写脚本进行控制。 简介Supervisor(http://supervisord.org)是一个用Python写的进程管理client/server系统工具，能够让用户检测和控制UNIX型操作系统上进程，支持Linux、Mac OS X，windows上不能使用。它能够用来方便地监听、重启、启动、关闭一个或者多个进程。当用supervisor管理的一个进程意外被kill，supervisor能够监听到进程杀死，会自动将它重启，做到自动恢复的功能，不需写shell脚本进行控制。 安装方式Ubuntu上：apt-get install supervisorCentos上：yum install supervisor用这些基于源的方式安装，supervisor的版本可能会比较老。推荐使用基于python的安装方式：easy_install supervisor或者是基于pip的安装方式：pip install supervisor 配置直接输入echo_supervisord_conf命令能够将默认配置项输出到terminal。但一般需要重定向到一个配置文件中：echo_supervisord_conf &gt; /etc/supervisord.conf如果没有root权限，可以重定向到自定义路径的配置文件：echo_supervisord_conf &gt; [directory]/[yourconf] 管理配置文件安装完成后，用户通过编写配置文件来满足自己的需求，这些配置都可以写到supervisord.conf里。如果应用程序很多，最好通过include的方式把不同程序（组）写到不同的配置文件里。12[include]files = /etc/supervisor/*.conf 需要改动的配置信息有这些：12345678910111213[program:server] ;写你的程序名字directory = /home/xxx ; 程序的启动目录command = sh run.sh ; 启动命令，与命令行启动的命令是一样的autostart = true ; 在 supervisord 启动的时候也自动启动startsecs = 5 ; 启动 5 秒后没有异常退出，就当作已经正常启动了autorestart = true ; 程序异常退出后自动重启startretries = 3 ; 启动失败自动重试次数，默认是 3user = xxx ; 用哪个用户启动redirect_stderr = true ; 把 stderr 重定向到 stdout，默认 falsestdout_logfile_maxbytes = 20MB ; stdout 日志文件大小，默认 50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile = /etc/supervisord.d/log/confd.log ;日志统一放在log目录下 启动supervisor启动进程：supervisord -c [directory]/[yourconf]（通过 -c 选项指定配置文件路径，如果不指定会按照以下路径查找配置文件：$CWD/supervisord.conf, $CWD/etc/supervisord.conf, /etc/supervisord.conf）通过命令行查看supervisord是否在运行：ps aux | grep supervisord设置开机启动以及systemd方式启动1234sudo chmod +x /etc/rc.d/init.d/supervisordsudo chkconfig --add supervisordsudo chkconfig supervisord onsudo service supervisord start 控制命令Supervisord有两个可用的命令行 supervisord（server端，之前用到了） supervisorctl（client端，是supervisord的命令行客户端工具，用来在控制supervisord） supervisorctl supervisorctl stop myprogram，停止某一个进程(myprogram)，myprogram为 [program:xxx] 里配置的进程名称。 supervisorctl start myprogram，启动某个进程。 supervisorctl restart myprogram，重启某个进程。 supervisorctl status，查看进程状态。 supervisorctl stop groupworker ，重启所有属于名为 groupworker 这个分组的进程(start,restart 同理)。 supervisorctl stop all，停止全部进程，注：start、restart、stop 都不会载入最新的配置文件。 supervisorctl reload，载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程。 supervisorctl update，根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启。 e.g.12$ supervisorctl statusserver RUNNING pid 19985, uptime 0:00:05 直接输入supervisorctl会进入shell交互界面。12$ supervisorctlsupervisor&gt; supervisordsupervisord用来初始启动supervisord，启动、管理配置中设置的进程。1234567891011121314151617181920212223242526272829$ supervisord --helpsupervisord -- run a set of applications as daemons.Usage: /usr/bin/supervisord [options]Options:-c/--configuration FILENAME -- configuration file-n/--nodaemon -- run in the foreground (same as 'nodaemon true' in config file)-h/--help -- print this usage message and exit-v/--version -- print supervisord version number and exit-u/--user USER -- run supervisord as this user (or numeric uid)-m/--umask UMASK -- use this umask for daemon subprocess (default is 022)-d/--directory DIRECTORY -- directory to chdir to when daemonized-l/--logfile FILENAME -- use FILENAME as logfile path-y/--logfile_maxbytes BYTES -- use BYTES to limit the max size of logfile-z/--logfile_backups NUM -- number of backups to keep when max bytes reached-e/--loglevel LEVEL -- use LEVEL as log level (debug,info,warn,error,critical)-j/--pidfile FILENAME -- write a pid file for the daemon process to FILENAME-i/--identifier STR -- identifier used for this instance of supervisord-q/--childlogdir DIRECTORY -- the log directory for child process logs-k/--nocleanup -- prevent the process from performing cleanup (removal of old automatic child log files) at startup.-a/--minfds NUM -- the minimum number of file descriptors for start success-t/--strip_ansi -- strip ansi escape codes from process output--minprocs NUM -- the minimum number of processes available for start success--profile_options OPTIONS -- run supervisord under profiler and output results based on OPTIONS, which is a comma-sep'd list of 'cumulative', 'calls', and/or 'callers', e.g. 'cumulative,callers') Supervisorctl 是 supervisord 的一个命令行客户端工具，启动时需要指定与 supervisord 使用同一份配置文件，否则与 supervisord 一样按照顺序查找配置文件。1supervisorctl -c /etc/supervisord.conf","link":"/2019/04/29/用Supervisor管理进程、监控程序/"},{"title":"markdown基本语法","text":"Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。 Markdown 为记录思想和分享知识提供更专业的工具。 可以使用 Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法需要在#后跟个空格再写文字。 示例： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 示例： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;直到n个 示例： 这是引用的内容 这是引用的内容 这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 * 都可以。 示例： 效果如下： 可以看到，显示效果是一样的。 图片语法： 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 效果如下： 超链接语法：超链接名title可加可不加 示例： hexogithub 效果如下：hexogithub 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例Github 列表 无序列表语法：无序列表用 - + * 任何一种都可以 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 有序列表语法：数字加点 1.列表内容2.列表内容3.列表内容 注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格语法： 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码：代码之间分别用一个反引号包起来 代码内容 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行(12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 代码... 代码... 代码...(```)注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。示例：单行代码&gt; `create database hero;`代码块&gt; (```)&gt; function fun(){&gt; echo &quot;这是一句非常牛逼的代码&quot;;&gt; }&gt; fun();&gt; (```)效果如下：单行代码`create database hero;`代码块function fun(){ echo &quot;这是一句非常牛逼的代码&quot;;}fun();### 流程图### 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)- [ ] 支持以 PDF 格式导出文稿- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率- [x] 新增 Todo 列表功能- [x] 修复 LaTex 公式渲染问题- [x] 新增 LaTex 公式编号功能### 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$### 高亮一段代码[^code]```python@requires_authorizationclass SomeClass: passif __name__ == &apos;__main__&apos;: # A comment print &apos;hello world&apos; 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","link":"/2018/12/22/markdown基本语法/"},{"title":"hexo及icarus主题个性定制","text":"icarus个性定制配置修改的一些内容。 前言此篇不介绍hexo的搭建，网上教程已经很完善，这里讲我用icarus做的一些个性化配置。 语言切换Icarus提供多语言切换，默认是英文的。为了改成中文，进入项目目录，修改_config.yml 中的language: zh-CN 增加文章字间距icarus中文显示字体有点挤。在icarus/xiansource/css/style.styl中.article .content的部分加上letter-spacing: 0.08rem; 加宽中心文章的布局icarus默认的文章区域比较窄，我想改得宽一点，突出文章内容。解决办法： 打开themes/icarus/layout/layout.ejs 改变main_column_class()中case 3的返回值 原值为is-8-tablet is-8-desktop is-6-widescreen 我改成了is-10-tablet is-10-desktop is-8-widescreen 但是重新部署的时候，会出现整体内容不居中解决办法：通过开发者工具可以看到生成的container.saas文件里，margin-left和margin-right都是auto在icarus/source/css/style.sytl中加上属性12345678910111213141516171819 .container margin-left: 2rem; margin-right: 2rem;``同时为了让navbar居中把在同一个文件中@media screen and (mid-width: screen-fullhd)的部分里把@media screen and (min-width: screen-fullhd) 部分改成```css @media screen and (min-width: screen-fullhd) .is-3-column .container max-width: 1600px margin-left: 2rem; margin-right: 2rem; .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap margin-left: auto; margin-right: auto; .is-1-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap 更改友情链接布局icarus本身的链接布局是一列一列的，左边昵称，右边链接。我为了省空间，把跳转链接直接加到昵称上，让两个昵称左右分布。更改links.ejs文件里div class=&quot;card-content&quot;部分123456789101112131415161718192021222324&lt;div class=\"menu links\"&gt; &lt;h3 class=\"menu-label\"&gt; &lt;%= __('widget.links') %&gt; &lt;/h3&gt; &lt;ul class=\"menu-list\"&gt; &lt;% let flag = 1; for (let i in links) { %&gt; &lt;% if (flag == 1) { %&gt; &lt;li&gt; &lt;a class=\"level is-mobile\" href=\"&lt;%- links[i] %&gt;\" target=\"_blank\"&gt; &lt;span class=\"level-left\" style=\"text-decoration: underline\"&gt; &lt;span class=\"level-item\"&gt;&lt;%= i %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;% flag = 0;} else {%&gt; &lt;a class=\"level is-mobile\" href=\"&lt;%- links[i] %&gt;\" target=\"_blank\"&gt; &lt;span class=\"level-right\" style=\"text-decoration: underline\"&gt; &lt;span class=\"level-item\"&gt;&lt;%= i %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;% flag = 1;} %&gt; &lt;% } %&gt; &lt;/ul&gt;&lt;/div&gt; style.style中widget部分改为123456789101112.widget .media border: none .media + .media margin-top: 0 .menu-list li ul margin-right: 0 a.level display: flex .links .menu-list a.level display: inline-block 给博客增加自定义目录在article.ejs中添加123456789&lt;div class=\"content\"&gt; &lt;% if(!index &amp;&amp; post.ttoc == true){ %&gt; &lt;div id=\"toc\" class=\"toc-article\"&gt; &lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;% } %&gt; &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt;&lt;/div&gt; 对于需要添加目录的博客，在header中添加ttoc: true 为博客增加分享功能icarus提供多个分享插件。 AddThis AddToAny Baidu Share Share.js ShareThis 我选择share.js插件，它可以一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等社交网站。设置步骤：123_config.ymlshare: type: sharejs 给blog增加点击爱心效果创建js文件在/themes/icarus/source/js/src下新建文件clicklove.js，接着把该链接下的代码拷贝粘贴到clicklove.js文件中。123456789101112131415161718192021222324252627282930313233343536373839404142!function(e,t,a){ function n(){ c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r() } function r(){ for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\"); requestAnimationFrame(r) } function o(){ var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e){ t&amp;&amp;t(),i(e) } }function i(e){ var a=t.createElement(\"div\"); a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a) } function c(e){ var a=t.createElement(\"style\");a.type=\"text/css\"; try{ a.appendChild(t.createTextNode(e)) } catch(t){ a.styleSheet.cssText=e } t.getElementsByTagName(\"head\")[0].appendChild(a) } function s(){ return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\" } var d=[]; e.requestAnimationFrame=function(){ return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){ setTimeout(e,1e3/60) } }(), n()}(window,document); 修改layout.ejs文件在/theme/icarus/layout/layout.ejs的&lt;!DOCTYPE html&gt;之后增加语句1&lt;script src=\"/js/clicklove.js\"&gt;&lt;/script&gt; 增加看板娘插件live2D安装使用 npm 安装：在 Hexo 项目的根目录运行命令：1npm install --save hexo-helper-live2d 3.0.1 版本存在的 bug：存在代码注入 bug，与 hexo-tag-dplayer 插件产生冲突，导致相关脚本无法加载。解决方法：在项目中使用 npm 命令手动卸载 “hexo-tag-dplayer”: “^0.3.1”。参阅GitHub issue 给文章日期/分类/标签增加图标Icarus主题下的这些没有图标，但我想加图标的话怎么办？hexo里可以使用FontAwesome图标CSS样式加上字体库实现图标的引用。其它网站开发中也可以使用。 引入Icarus主题源文件中已经引用了CSS文件，可直接跳过这部分。 使用图标之前需要引入 CSS 文件,这里选用 FontAwesome 4.4.0 版本。1&lt;link href=\"//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css\" rel=\"stylesheet\"&gt; 当然,还可以使用离线包,我们可以去官网下载它。http://fontawesome.io/ 使用1&lt;i class=\"fa fa-home\"&gt;&lt;/i&gt; 图标CSS清单可参考博客 文章做成两格布局文件改动includes/helpers/layout.js中12hexo.extend.helper.register(&apos;column_count&apos;, function () { let columns = 1; 后添加123if (this.page.__post === true || this.page.__page === true) { return 2;} layout/common/widget.ejs中1&lt;%- partial('common/widget', { position: 'right' }) %&gt; 改成123&lt;% if (page.__page !== true &amp;&amp; page.__post !== true) { %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt;&lt;% } %&gt; layout/layout.ejs中hexo.extend.helper.register('column_count', function () { let columns = 1;后添加123 if (this.page.__post === true || this.page.__page === true) { return 2;} 但这样左边栏显示变宽了，我觉得不是很好看，怎么办呢？ 把layout/common/widget.ejs中side_column_class()的case 2的返回值改成return 'is-4-tablet is-4-desktop is-3-widescreen';就好啦！ 更多细则可以参考作者项目的issue(作者是个勤于回复的人！特别好！) 添加文章更新时间 修改（博客主目录/themes/icarus/layout/common/article.ejs文件，在&lt;time class=&quot;level-item has-text-grey&quot; datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot;&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;标签后添加 1234&lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt; &lt;i class=\"fas fa-calendar-check\"&gt;&amp;nbsp&lt;/i&gt; &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.updated) %&gt;\"&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;&lt;% } %&gt; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/icarus/languages/zh_CN.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/icarus/_config.yml，增加一行 1display_updated: true 写文章的时候可以直接在文章开头设置更新时间updated: 2018-01-01 12:00:00没有这参数的话将会显示md文件的修改日期 优化访问速度To be continued…","link":"/2018/12/24/icarus个性定制/"},{"title":"关于我和3DGNN论文及源码的爱恨情仇","text":"配这篇论文源码的环境的过程实在是太艰难了。也 太 艰 难 了。究竟是什么样的狠人才会用matlab + caffe的环境啊！！ 参考论文3D Graph Neural Networks for RGBD Semantic Segmentation源码在仓库3DGNN 预先配好的环境：Ubuntu 16.04(64bit) cuda: 8.0 cudnn: 5.1 OpenCV: 3.4.3 Matlab: R2016b 显卡: GeForce 1080Ti x2 安装MATLAB我的服务器是无图形界面的，安装MATLAB的时候要开启mode=silent。并且因此无法通过网络下载matlab需要用到的toolbox库，所以必须要挂载iso镜像。 在进行make matcaffe之前，要解决几个编译器版本的问题。在安装路径xxx/MATLAB/R2016b/sys/os/glnxa64下把 libstdc++.so.6 重命名为 libstdc++.so.6_back12sudo mv libstdc++.so.6 libstdc++.so.6_backsudo ldconfig 这时Matlab找不到libstdc++.so.6，会找到系统文件下的/usr/lib/libstdc++.so.6 处理这个问题的另外一个办法是建立一个soft link（为一个lib建立一个重定向，以后要找这个名字的lib，会定向到指定的lib那里）123cd /usr/local/MATLAB/R2016b/sys/os/glnxa64sudo rm libstdc++.so.6sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21 libstdc++.so.6 安装caffemake all -j8 make test -j8 make runtest -j8 错误信息: 找不到hdf5 fatal error: hdf5.h: No such file or directory 解决办法一在caffe文件夹下的MakeFile.configINCLUDE_DIRS := 最后加上 /usr/include/hdf5/serial/LIBRARY_DIRS := 最后加上 /usr/lib/x86_64-linux-gnu/hdf5/serial/保存，重新编译即可。 解决办法二（如果有root权限）增加软连接：cd /usr/lib/x86_64-linux-gnusudo ln -s libhdf5_serial.so.8.0.2 libhdf5.sosudo ln -s libhdf5_serial_hl.so.8.0.2 libhdf5_hl.so 错误信息：找不到-lhdf5 LD -o .build_release/lib/libcaffe.so.1.0.0-rc3/usr/bin/ld: cannot find -lhdf5collect2: error: ld returned 1 exit statusMakefile:563: recipe for target ‘.build_release/lib/libcaffe.so.1.0.0-rc3’ failedmake: *** [.build_release/lib/libcaffe.so.1.0.0-rc3] Error 1 解决办法：改Makefile里LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_serial_hl hdf5_serial 错误信息：关于cudnn In file included from ./include/caffe/util/device_alternate.hpp:40:0, from ./include/caffe/common.hpp:19, from src/caffe/common.cpp:7:./include/caffe/util/cudnn.hpp: In function ‘void caffe::cudnn::createPoolingDesc(cudnnPoolingStruct, caffe::PoolingParameter_PoolMethod, cudnnPoolingMode_t, int, int, int, int, int, int)’:./include/caffe/util/cudnn.hpp:127:41: error: too few arguments to function ‘cudnnStatus_t cudnnSetPooling2dDescriptor(cudnnPoolingDescriptor_t, cudnnPoolingMode_t, cudnnNanPropagation_t, int, int, int, int, int, int)’ pad_h, pad_w, stride_h, stride_w)); ^./include/caffe/util/cudnn.hpp:15:28: note: in definition of macro ‘CUDNN_CHECK’ cudnnStatus_t status = condition; \\ ^In file included from ./include/caffe/util/cudnn.hpp:5:0, from ./include/caffe/util/device_alternate.hpp:40, from ./include/caffe/common.hpp:19, from src/caffe/common.cpp:7:/usr/local/cuda-7.5//include/cudnn.h:803:27: note: declared here cudnnStatus_t CUDNNWINAPI cudnnSetPooling2dDescriptor( ^make: [.build_release/src/caffe/common.o] Error 1 参考链接(https://blog.csdn.net/u011070171/article/details/52292680)[https://blog.csdn.net/u011070171/article/details/52292680] 这是因为当前版本的caffe的cudnn实现与系统所安装的cudnn的版本不一致引起的。 解决办法(害怕自己有失误的宝宝要记得备份哦)： git clone最新版本的caffe源码 将./include/caffe/util/cudnn.hpp 换成最新版的caffe里的cudnn的实现，即相应的cudnn.hpp. 将./include/caffe/layers里的，所有以cudnn开头的文件，例如cudnn_conv_layer.hpp。 都替换成最新版的caffe里的相应的同名文件。 将./src/caffe/layers里的，所有以cudnn开头，以.cpp或者.cu结尾的文件，例如cudnn_lrn_layer.cu，cudnn_pooling_layer.cpp，cudnn_sigmoid_layer.cu，都替换成最新版的caffe里的相应的同名文件。 错误信息：cannot find -lopencv_dep_cudart /usr/bin/ld: cannot find -lopencv_dep_cudartcollect2: error: ld returned 1 exit statussrc/caffe/CMakeFiles/caffe.dir/build.make:4285: recipe for target ‘lib/libcaffe.so.1.0.0-rc3’ failedmake[2]: [lib/libcaffe.so.1.0.0-rc3] Error 1CMakeFiles/Makefile2:272: recipe for target ‘src/caffe/CMakeFiles/caffe.dir/all’ failedmake[1]: [src/caffe/CMakeFiles/caffe.dir/all] Error 2Makefile:127: recipe for target ‘all’ failedmake: *** [all] Error 2 解决办法：需要在bash里set CUDA_USE_STATIC_CUDA_RUNTIME=off，再make 错误信息：make的时候libcaffe.so出错 undefined reference to cv:: .build_release/lib/libcaffe.so: undefined reference to `cv::_InputArray::_InputArray(cv::Mat const&amp;)’ .build_release/lib/libcaffe.so: undefined reference to `cv::imdecode(cv::_InputArray const&amp;, int)’ .build_release/lib/libcaffe.so: undefined reference to `cv::imencode(std::__cxx11::basic_string&lt;char, std::char_traits, std::allocator &gt; const&amp;, cv::_InputArray const&amp;, std::vector&lt;unsigned char, std::allocator &gt;&amp;, std::vector&lt;int, std::allocator &gt; const&amp;)’ .build_release/lib/libcaffe.so: undefined reference to `CvKNearest::CvKNearest(CvMat const, CvMat const, CvMat const*, bool, int)’ ………………………………. collect2: error: ld returned 1 exit status Makefile:616: recipe for target ‘.build_release/tools/compute_image_mean.bin’ failed make: *** [.build_release/tools/compute_image_mean.bin] Error 1 出现这样的问题是因为caffe没有找到库。 可能原因： 使用的是opencv3版本需要在Makefile.config里把USE_OPENCV_VERSION := 3的注释去掉，再注释掉USE_PKG_CONFIG := 1。 没找到库路径可以使用LDD .build_release/lib/libcaffe.so查看libcaffe.so链接的动态链接库。如果出现libxxx.so =&gt; not found，则说明是库没找到，或者是原因3。需要先把库路径加在Makefile.config里LIBRARY_DIRS := …后面，再添加你需要的库到Makefile里libraries := …..的后面，即可。 找错了库路径Makefile找库的时候是按照Makefile.config里LIBRARY_DIRS变量值的顺序找的。如果在前面的库路径下存在你需要的库，就不会再从后面的库路径里找了。同样可以使用LDD .build_release/lib/libcaffe.so查看libcaffe.so链接的动态链接库，查看库路径是否正确。如果路径错误，可以对Makefile.config里LIBRARY_DIRS的顺序进行调整。 错误信息：make runtest error in `xxx/test/test.testbin’: free(): invalid pointer在使用caffe run test的时候，如果出现如下报错*** Error in xxx/test/test.testbin': free(): invalid pointer: 0x00007fbaf71accb8 *** 很可能是缺少libtcmalloc-minimal4库，首先安装sudo apt-get install libtcmalloc-minimal4 然后打开~/.bashrc文件vim ~/.bashrc 在文件末尾添加如下代码：export LD_PRELOAD=&quot;/usr/lib/libtcmalloc_minimal.so.4&quot; 最后重新载入环境变量即可source ~/.bashrc 编译及测试matcaffe接口编译matcaffemake matcaffe 设置opencv的软连接。如果直接用make matcaffe编译之后在matlab里测试，可能会出现以下错误，123Invalid MEX-file &apos;/home/dong/caffe/matlab/+caffe/private/caffe_.mexa64&apos;:/home/dong/caffe/matlab/+caffe/private/caffe_.mexa64: undefined symbol:_ZN2cv8imencodeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_11_InputArrayERSt6vectorIhSaIhEERKSB_IiSaIiEE 这是由于我编译caffe所使用的OpenCV（2.4.13）版本跟matlab自带的版本（2.4.9）不一致，导致找不到相关变量名。 这里需要重定向一下（顺便备份）：1234567cd /xxx/MATLAB/R2016b/bin/glnxa64sudo mv libopencv_core.so.2.4 libopencv_core.so.2.4_backsudo mv libopencv_highgui.so.2.4 libopencv_highgui.so.2.4_backsudo mv libopencv_imgproc.so.2.4 libopencv_imgproc.so.2.4_backsudo ln -s /usr/lib/x86_64-linux-gnu/libopencv_core.so.2.4.13 libopencv_core.so.2.4sudo ln -s /usr/lib/x86_64-linux-gnu/libopencv_highgui.so.2.4.13 libopencv_highgui.so.2.4sudo ln -s /usr/lib/x86_64-linux-gnu/libopencv_imgproc.so.2.4.13 libopencv_imgproc.so.2.4 测试matcaffe在进行make mattest前，要解决几个编译器版本的问题。 方法1在/usr/local/MATLAB/R2014b/sys/os/glnxa64下把 libstdc++.so.6 重命名为 libstdc++.so.6_backmv libstdc++.so.6 libstdc++.so.6_back这是Matlab找不到libstdc++.so.6之后，会到/usr/lib中找系统用到libstdc++版本 方法2处理这个问题的另外一个办法是建立一个soft link（为一个lib建立一个重定向，以后要找这个名字的lib，会定向到指定的lib那里） 123cd /usr/local/MATLAB/R2016b/sys/os/glnxa64sudo rm libstdc++.so.6sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21 libstdc++.so.6 进入matlab注意：caffe路径下生成的matlab folder里应该有+caffe folder，matcaffe需要用到的相关函数实现和文件都在这里。要先addpath('/your_caffe_path/matlan')才能让matlab找到matcaffe，在nyu_crop_data_mask_msc.m里找到gpu_id，选择你的机器上空闲的gpu id。 Terminal里用nvidia-smi指令显示gpu相关信息。 nvidia-smi后显示的信息如下图：123456789101112131415161718192021| NVIDIA-SMI 384.130 Driver Version: 384.130 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce GTX 108... Off | 00000000:17:00.0 Off | N/A || 33% 32C P0 54W / 250W | 0MiB / 11172MiB | 0% Default |+-------------------------------+----------------------+----------------------+| 1 GeForce GTX 108... Off | 00000000:65:00.0 Off | N/A || 33% 35C P0 50W / 250W | 0MiB / 11170MiB | 1% Default |+-------------------------------+----------------------+———————————+ 我这里的GPU序列有0和1，可以设置成gpu_id = 0或者gpu_id = 1。 (注意，matcaffe只能用单gpu训练网络)然后run nyu_crop_data_mask_msc.m，成功。 run matlabscript错误信息：unknown pooling method123456I0331 20:04:23.127297 49968 net.cpp:106] Creating Layer x_1_avepoolI0331 20:04:23.127324 49968 net.cpp:454] x_1_avepool &lt;- out_reduce_out_reduce_relu_0_split_0I0331 20:04:23.127333 49968 net.cpp:454] x_1_avepool &lt;- knn_knn_0_split_0I0331 20:04:23.127346 49968 net.cpp:411] x_1_avepool -&gt; x_1_avepoolF0331 20:04:23.127763 49968 cudnn.hpp:144] Unknown pooling method.*** Check failure stack trace: *** 这是因为源码中并没有用到cudnn。往前看一下输出，可以看到名字是x_1_avepool这层的定义 123456789101112layer { name: \"x_1_avepool\" type: \"Pooling\" bottom: \"out_reduce\" bottom: \"knn\" top: \"x_1_avepool\" pooling_param {​ pool: KNNPOOL​ kernel_size: 11​ pad: 5 }} 所以在util中的cudnn.h里，没有定义KNNPOOL的pooling method。注释掉Makefile.config里的USE_CUDNN即可 cmake错误信息：cmake的make不成功 src/caffe/test/test_gradient_based_solver.cpp:370: FailureThe difference between expected_updated_weight and solver_updated_weight is 1.1920928955078125e-07, which exceeds error_margin, whereexpected_updated_weight evaluates to 9.6857547760009766e-06,solver_updated_weight evaluates to 9.8049640655517578e-06, anderror_margin evaluates to 1.0000000116860974e-07.[ FAILED ] NesterovSolverTest/2.TestNesterovLeastSquaresUpdateWithEverythingShare, where TypeParam = caffe::GPUDevice (8073 ms)[ RUN ] NesterovSolverTest/2.TestLeastSquaresUpdateWithEverythingAccumShare[ OK ] NesterovSolverTest/2.TestLeastSquaresUpdateWithEverythingAccumShare (28 ms)[ RUN ] NesterovSolverTest/2.TestNesterovLeastSquaresUpdateWithEverythingsrc/caffe/test/test_gradient_based_solver.cpp:370: FailureThe difference between expected_updated_weight and solver_updated_weight is 1.1920928955078125e-07, which exceeds error_margin, whereexpected_updated_weight evaluates to 9.6857547760009766e-06,solver_updated_weight evaluates to 9.8049640655517578e-06, anderror_margin evaluates to 1.0000000116860974e-07.[ FAILED ] NesterovSolverTest/2.TestNesterovLeastSquaresUpdateWithEverything, where TypeParam = caffe::GPUDevice (7338 ms) 在make runtest之前，export CUDA_VISIBLE_DEVICES=0 再make runtest 就成功啦。","link":"/2019/03/23/关于我和3DGNN论文及源码的爱恨情仇/"},{"title":"简洁清爽的Stylus语法","text":"Stylus是一个基于Node.js的CSS的预处理框架。其本质上做的事情与sass/less等类似。Stylus比less更强大。icarus主题中用到了stylus。 Stylus介绍Stylus是一个基于Node.js的CSS的预处理框架。可以说是一种新型语言，其本质上做的事情与sass/less等类似。Stylus比less更强大；比sass更符合我们的思路。 它是一个CSS的预处理框架，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，所以 Stylus是一种新型语言，可以创建健壮的、动态的、富有表现力的CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似，应该是有很多借鉴，所以近似脚本的方式去写CSS代码。 Stylus默认使用 .styl 的作为文件扩展名，支持多样性的CSS语法。 Stylus功能上更为强壮，和js联系更加紧密。 对于开发来说，CSS的弱点在于静态化。我们需要一个真正能提高开发效率的工具，LESS， SASS都在这方面做了一些贡献。 安装全局安装，安装之前你需要先安装nodejs。1$ npm install stylus -g 苹果电脑（mac系统）以上命令或许不成功 mac系统建议以下方式进行安装1$ sudo npm install stylus -g 这样就算是安装完Stylus了，也可以正常使用Stylus。 123456789101112131415161718192021Usage: stylus [options] [command] [&lt; in [&gt; out]] [file|dir ...]Commands: help &lt;prop&gt; Opens help info for &lt;prop&gt; in your default browser. (OS X only)Options: -u, --use &lt;path&gt; Utilize the stylus plugin at &lt;path&gt; -i, --interactive Start interactive REPL -w, --watch Watch file(s) for changes and re-compile -o, --out &lt;dir&gt; Output to &lt;dir&gt; when passing files -C, --css &lt;src&gt; [dest] Convert CSS input to Stylus -I, --include &lt;path&gt; Add &lt;path&gt; to lookup paths -c, --compress Compress CSS output -d, --compare Display input along with output -f, --firebug Emits debug infos in the generated css that can be used by the FireStylus Firebug plugin -l, --line-numbers Emits comments in the generated CSS indicating the corresponding Stylus line -V, --version Display the version of Stylus -h, --help Display help information 生成CSS命令行中建立一个stylusExample/，再在里面建立 src 目录专门存放 stylus 文件，在里面建立 example.styl 文件。然后在 stylusExample 目录下面执行下面命令1$ stylus --compress src/ 输出compiled src/example.css ，这个时候表示你生成成功了，带上–compress参数表示你生成压缩的CSS文件。123$ stylus --css css/example.css css/out.styl CSS转换成styl $ stylus help box-shadow CSS属性的帮助 $ stylus --css test.css 输出基本名一致的.styl文件 应用效果Try Stylus!stylus123body,html margin:0 padding:0 编译成12345body,html { margin: 0; padding: 0;} stylus : 强大的功能丰富的语言1234567891011121314151617181920-pos(type, args) i = 0 position: unquote(type) {args[i]}: args[i + 1] is a 'unit' ? args[i += 1] : 0 {args[i += 1]}: args[i + 1] is a 'unit' ? args[i += 1] : 0absolute() -pos('absolute', arguments)fixed() -pos('fixed', arguments) #prompt absolute: top 150px left 5px width: 200px margin-left: -(@width / 2) #logo fixed: top left 编译成123456789101112#prompt { position: absolute; top: 150px; left: 5px; width: 200px; margin-left: -100px; #logo { position: fixed; top: 0; left: 0;} nibStylus插件stylus123@import 'nib'body background: linear-gradient(20px top, white, black) 编译成1234567body { background: -webkit-linear-gradient(20px top, #fff, #000); background: -moz-linear-gradient(20px top, #fff, #000); background: -o-linear-gradient(20px top, #fff, #000); background: -ms-linear-gradient(20px top, #fff, #000); background: linear-gradient(20px top, #fff, #000);} Nesting(嵌套)stylus123header #logo border:1px solid red 编译成123header #logo { border: 1px solid #f00;} Flexible syntax(灵活的用法)更多详细示例可参考stylus中文文档，或者stylus官方文档。 stylus1234567891011body font 14px/1.5 Helvetica, arial, sans-serif button button.button input[type='button'] input[type='submit'] border-radius 5pxheader #logo,div font-size:14px 编译成123456789101112body { font: 14px/1.5 Helvetica, arial, sans-serif;}body button,body button.button,body input[type='button'] { border-radius: 5px;}header #logo,header div { font-size: 14px;} Flexible &amp;(灵活&amp;)stylus123456789ul li a display: block color: blue padding: 5px html.ie &amp; padding: 6px &amp;:hover color: red 编译成1234567891011ul li a { display: block; color: #00f; padding: 5px;}html.ie ul li a { padding: 6px;}ul li a:hover { color: #f00;} Functions 方法返回值带参数stylus1234567border-radius(val) -webkit-border-radius: val -moz-border-radius: val border-radius: valbutton border-radius(5px); 编译成123456button { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;}Transparent mixins 不带参数stylus1234567border-radius() -webkit-border-radius: arguments -moz-border-radius: arguments border-radius: argumentsbutton border-radius: 5px 10px; 编译成12345button { -webkit-border-radius: 5px 10px; -moz-border-radius: 5px 10px; border-radius: 5px 10px;} 默认参数不带参数1234567891011stylusadd(a, b = a) a + badd(10, 5)// =&gt; 15add(10)// =&gt; 20函数体 通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。1234567add(a, b = a) a = unit(a, px) b = unit(b, px) a + badd(15%, 10deg)// =&gt; 25 多个返回值通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。12345sizes() 15px 10pxsizes()[0]// =&gt; 15px Variables(变量)常用方法stylus123font-size = 14pxbody font font-size Arial, sans-seri 编译成123body { font: 14px Arial, sans-seri;} 变量放在属性中stylus123456#prompt position: absolute top: 150px left: 50% width: w = 200px margin-left: -(w / 2) 编译成1234567 #prompt { position: absolute; top: 150px; left: 50%; width: 200px; margin-left: -100px;} 块属性访问引用stylus1234#prompt position: absolute width: 200px margin-left: -(@width / 2) 编译成12345 #prompt { position: absolute; width: 200px; margin-left: -100px;} 属性有条件地定义属性stylus:指定z-index值为1，但是，只有在z-index之前未指定的时候才这样：12345678position() position: arguments z-index: 1 unless @z-index #logo z-index: 20 position: absolute #logo2 position: absolute 编译成12345678 #logo { z-index: 20; position: absolute;} #logo2 { position: absolute; z-index: 1;} 向上冒泡stylus:属性会“向上冒泡”查找堆栈直到被发现，或者返回null（如果属性搞不定）下面这个例子，@color被弄成了blue.1234567body color: red ul li color: blue a background-color: @color 编译成123456789body { color: #f00;}body ul li { color: #00f;}body ul li a { background-color: #00f;} Iteration(迭代)stylus1234table for row in 1 2 3 4 5 tr:nth-child({row}) height: 10px * row 编译成123456789101112131415table tr:nth-child(1) { height: 10px;}table tr:nth-child(2) { height: 20px;}table tr:nth-child(3) { height: 30px;}table tr:nth-child(4) { height: 40px;}table tr:nth-child(5) { height: 50px;} Interpolation(插值)stylus123456789vendors = webkit moz o ms officialborder-radius() for vendor in vendors if vendor == official border-radius: arguments else -{vendor}-border-radius: arguments#content border-radius: 5px 编译成1234567#content { -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; -ms-border-radius: 5px; border-radius: 5px;} Operators(运算符)运算符优先级：下表运算符优先级，从最高到最低：123456789101112131415161718. [] ! ~ + - is defined ** * / % + - ... .. &lt;= &gt;= &lt; &gt; in == is != is not isnt is a &amp;&amp; and || or ?: = := ?= += -= *= /= %= not if unless@import@import \"reset.css\" 当使用@import没有.css扩展，会被认为是Stylus片段（如：@import “mixins/border-radius”）。 @import工作原理为：遍历目录队列，并检查任意目录中是否有该文件（类似node的require.paths）。该队列默认为单一路径，从filename选项的dirname衍生而来。 因此，如果你的文件名是/tmp/testing/stylus/main.styl，导入将显现为/tmp/testing/stylus/。 @import也支持索引形式。这意味着当你@import blueprint, 则会理解成blueprint.styl或blueprint/index.styl. 对于库而言，这很有用，既可以展示所有特征与功能，同时又能导入特征子集。 @font-facestylus123456@font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf).ingeo font-family Geo 编译成123456789@font-face { font-family: Geo; font-style: normal; src: url(“fonts/geo_sans_light/GensansLight.ttf”); } .ingeo { font-family: Geo; } @media stylus1234@media print #header #footer display none 编译成1234567@media print { #header, #footer { display: none; } } @keyframes stylus1234567@keyframes pulse 0% background-color red transform scale(1.0) rotate(0deg) 33% background-color blue -webkit-transform scale(1.1) rotate(-5deg) 编译成12345678910111213141516171819202122232425262728293031323334353637383940@-moz-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@-webkit-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@-o-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }} CSS字面量(CSS Literal)stylus12345@css { body { font: 14px; }} 编译成123body { font: 14px;}","link":"/2018/12/31/简洁清爽的Stylus语法/"},{"title":"面向对象设计原则","text":"一些基本的面向对象设计原则。 面向对象设计原则1. SRP所谓SRP原则，即：Single Responsibility Principle，单一职责原则。原始定义如下： There should never be more than one reason for a class to change.(只有一个引起类改变的原因) 在面向对象编程领域中，单一职责原则（Single responsibility principle）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。 单一职责的好处： 类的复杂性降低，实现什么职责都有清晰明确的定义; 可读性提高，复杂性降低，可维护性提高; 变更引起的风险降低。 单一职责原则的注意点： 单一职责最难划分的是职责。 单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。 2. LSP所谓LSP原则，即：Liskov Substitution principle，里氏替换原则。原始定义如下： Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象） 更通俗的定义即为：子类可以扩展父类的功能，但不能改变父类原有的功能。里氏替换原则包含了以下4层含义： 子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。 子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。 覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。 覆盖或实现父类的方法时输出结果可以被缩小。 优点： 提高代码的重用性，子类拥有父类的方法和属性； 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性； 缺点： 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性； 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。 3. ISP所谓ISP原则，即：Interface Segregation Principle，接口隔离原则。原始定义如下： Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。) 即，接口尽量细化，接口中的方法尽量少。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 4. OCP所谓OCP原则，即：Open Closed Principle，开闭原则。原始定义如下： software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭) 开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：对扩展开放，对修改关闭。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。 软件系统中包含的各种组件，例如模块（Module）、类（Class）以及功能（Function）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。 实现开闭原则的关键就在于“抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。 开闭原则的好处： 可复用性好; 可维护性好。 5. DIP所谓DIP原则，即：Dependency Inversion Principle，依赖倒置原则。原始定义如下： High-level modules should not depend on low-level modules. Both should depend on abstractions.(高层模块不应该依赖低层模块，两者都应该依赖其抽象) Abstractions should not depend on details. Details should depend on abstractions.(抽象不应该依赖细节；细节应该依赖抽象) 面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。 依赖倒置原则主要有以下三层含义： 高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）； 抽象不应该依赖细节（具体实现）； 细节（具体实现）应该依赖抽象。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想就是面向接口编程。 6. LOD | LKP所谓LOD原则，即：Law of Demeter，迪米特法则，又叫最少知识原则（Least Knowledge Principle，简写LKP），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下： talk only to your immediate friends.(只与直接的朋友通信) 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。 迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。 7. CRP所谓CRP原则，即：Composite Reuse Principle，组合复用原则。 组合复用原则的核心思想是：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。 继承的缺点主要有以下几点： 继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。 基类的实现发生了改变，派生类的实现也不得不改变。 从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处： 新对象存取组成对象的唯一方法是通过组成对象的getter/setter方法。 组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。 组合复用所需要的依赖较少。 每一个新的类可以将焦点集中到一个任务上。 组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。 组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。 组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 使用继承时必须满足Is-A的关系是才能使用继承，而组合却是一种Has-A的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把Has-A当成了Is-A。","link":"/2019/01/12/面向对象设计原则/"},{"title":"给计算机科学毕业生的职业生涯建议","text":"无意中看到了这篇文章，文中讨论了如何选择要不要读博/选择创业公司还是大型企业等人生岔路。写得很好，分享给大家! 原文在 https://huyenchip.com/2018/10/08/career-advice-recent-cs-graduates.html Career advice for recent Computer Science graduatesEver since graduation, people have been asking me: “What’s now?” My answer has been an unequivocal: “I don’t know.” I used to think that by the time I finished my master’s degree, I would know what to do. I thought I’d be a “master”. Boy, was I wrong. School did little to prepare me for the post-school world. The academic environment provides continual feedback – you go off track a little and somebody is sure to let you know, even guide you back in. In real world, I have this fear that I’ll make a series of wrong decisions and nobody will tell me until it’s too late. A wrong job choice could cost me a few years, together with many opportunities that should have come with a better choice. When I looked up career advice for recent graduates online, most of the articles I found are concerned with how to get a job. I don’t want to sound like a snob, but realistically, for many recent grads with degrees in a demanding field like CS, the question is less about “what job can I get” and more about “what job should I get.” The availability of options doesn’t make the decision any easier. If anything, it threw someone with a massive case of FOMO like me into panic mode. I kept iterating through a series of questions: “Should I do a PhD?”, “Should I work for a big company or a startup?”, “Should I do my own startup?”, “Should I do engineering or something more social?”, “Should I just leave tech and pursue my passion for writing?” Over the last year, I’ve bothered many people, both in industry and academia, with these questions, and I’ve been so lucky that some of them were kind enough to sit me down and share their insights with me. As their advice was extremely helpful to me, I thought they might be also useful for others who will one day have to go through the process that I did. This article is an attempt to put into words the overwhelming thought process that I went through and the advice that I received. If you just want the advice without the storytelling, go straight to the last section. PhD or no PhDMy family farms in a small village in Vietnam, so the US academic world was obscure to me. I had no idea what a PhD was about, what people looked for in an PhD application, or how I should prepare for it if I ever wanted to apply. It was only when I started hanging out with PhD students at the beginning of my last year that I realized: “Wow, these people are really smart. They work on interesting problems. I want to be like them.” I quickly realized that “PhD or no PhD” is a topic that everyone seemed to have an opinion on. I also realized that 100% of the professors I talked to (aka those who already did their PhDs) told me I should do a PhD, and 100% of the people in industry told me I should not. Arguments supporting PhD include: You’ll have time to immerse yourself in research. If you want to become a professor, you have to do a PhD. Many top research labs such as DeepMind only interview PhD candidates. You won’t be too poor as AI internships pay well. Arguments supporting no-PhD include: There should be more people joining industry to bring research into production. By the time you finish your PhD, what you learn might no longer be relevant. Many professors have side gigs in the industry anyway so you can still work with them. You won’t be poor for the next five years. I decided to go with PhD. Since it was too late for me to prepare my PhD app, my professors suggested that I apply next year and spend the year in between strengthening my app, so I lined up a bunch of research internships. I graduated a quarter early and spent the next three months traveling. I wasn’t trying to find myself, but I stumbled upon it. During that time, I wrote every day for fun but didn’t read a single paper. I realized that I wanted to do PhD not because I wanted to do AI research, but because I wanted to be the person who did AI research. The notion strengthened when I caught up with my PhD friends and saw them spend every waking moment talking/thinking about AI – I didn’t share their passion. I wanted something different. How different? I was still trying to figure it out. Be a sell-out or follow your passionStanford offers a CS + English major. We used to joke that this major is for those who love writing but also want to get a job. Then a friend told me I was one of those. I didn’t major in CS for the sake of getting a job. I got hooked on it from the first introductory class because the subject was fascinating. I love engineering, but my three months off rekindled the belief that writing is the biggest love of my life. Since I already spent nearly 4 years pursuing my degrees in CS, I longed to have some time invested in writing. I was also afraid of settling into the stereotypical complacency of being just another software engineer in Silicon Valley. Pursuing your passion, it turns out, is not legal in the US when you’re an international student. To stay in the US, I have to have a job related to my field of study. I can, of course, go live in another country. The idea of living on some South American beach and writing is quite romantic. But AI is such a fast-changing field that I was already a bit disoriented after a quarter off – what if I couldn’t get back into the field after a year? Plus, logistics and immigration would be a nightmare. When I came to my professor with this dilemma, he was confused: “Why do you have to choose between engineering and writing? Why not both?” There are many people who are accomplished in their technical fields but also prolific writers. His unquestioning confidence in my ability to do both inspired my own confidence: “You’re right. I can do both.” I can work full time in tech and spend evenings/weekends writing. I used to spend an ungodly amount of time doing homework + teaching in college so I’m sure I can spare 20+ hr/week for writing. Should I do my own startup?Graduating from Stanford and living in Silicon Valley, I can’t escape the startup stereotype. Some have suggested that I’m the “startup type.” Some have even asked me to become their co-founder. I have, more than once, been tempted. The idea of building something from scratch is appealing. I’ll undoubtedly learn a lot, not only about the problem I try to solve but also about how to inspire people to work with me, how to raise money, how to run an organization, how to sell my product… I have a lot of friends doing their own startups and their lives are a lot of things, but never boring. Plus, they have a substantially larger chance of becoming billionaires than I do. Just reading news about this or that twenty-something raising millions of dollars makes it seem so easy. “Even that Yo app raised $1.5M!” someone once cited this as a reason why I should do a startup. But I’ve also seen enough of my friends to know that the startup life is stressful, cut-throat, and constrained by so many external factors. A fair share of my friends’ startups have already failed even though they are extremely smart, had great ideas and were backed by prestigious investors. Every time I feel like crap, I call up my startup friends, see their struggles, and feel glad that I’m not them. I might be in the minority here, but I think starting a company just for the sake of starting a company is devoid of reason and a waste of everyone’s time. I wouldn’t start my own company until I’ve got at least three things: A problem I want to dedicate my life to solve.A belief that I can solve it.A co-founder I can work with for an extended period of time without either of us trying to murder the other.Right now, I have none of those, so I’ll just hang around. I also think that working for someone else for a few years will much better prepare me, both finance-wise and skill-wise, to work for myself. Big companies or startupsWith the above factors internalized, I started my internship at NVIDIA. I cancelled my other internship plans and looked into full-time jobs. That was when my next big question arose: “Should I work for a big company or a startup?” I had interned at both a big company and a startup during my undergrad. My impressions were very much aligned with what is usually said of the trade-off between big company stability and startup high impact (and high risk). Among my friends who chose not to do PhD, about 40% went to big companies, 40% worked for startups, and the rest started their own companies. They all gave me compelling arguments. The pros/cons below, of course, vary from company to company. When I shared this concern with people, many told me to do what made me happy. While I appreciate the sentiment, this advice often left me even more confused. What does “happiness” even mean? How am I supposed to measure it? “Happiness” is also relative. Given enough time for adjustment, we can teach ourselves to be happy with just about anything. There were two pieces of advice that I found helpful. The first was: “Which one gives you a once-in-a-lifetime opportunity?” Do you believe that the startup you’re considering is working on something truly important and it’s your once-in-a-lifetime opportunity to contribute to it? Or do you believe that working for a tech giant is your once-in-a-lifetime opportunity? The second was: “What are you optimizing for?” An easy thing to optimize for is money. Some of my friends interview with multiple companies and go to the highest bidder. Some optimize for new experiences and choose a job that allows them to travel and meet a lot of people. Some optimize for prestige and go to the company that is the most well-known in their field. At this stage in my life, I optimize for personal growth. I want a job that gives me the most freedom to grow. It means that the job should allow me to work with great colleagues/mentors and challenge myself as much as possible. NVIDIAIn the end, I chose to stay at NVIDIA for the following reasons. 1. The cultureI’ve talked to many companies, and NVIDIA stands out as a big company that feels like a startup. One of the NVIDIA’s cultural tenets is SOL, speed of light – you have to move fast, much faster than a regular big organization. I talked to my manager about converting to full-time one afternoon and got my offer the next day. On Glassdoor, some say that the startup-like culture means a higher workload. Some find the lack of organizational structure at NVIDIA disorienting. But I absolutely love the dynamics. As the company is growing so fast, there are so much to do. An employee can go out there and challenge themselves as much as they want. The hierarchy is flat. You can reach out to everyone and they will listen to you. Even as an intern, I had the opportunity to work with two senior managers. Jensen Huang once offered me a beer. My experience is far from unique. Also, Jensen Huang is the coolest CEO ever. His style is fire (leather jacket yo) and he has a wicked sense of humor. He invited all interns to his house for an end of summer party and everyone loved him. It takes a cool CEO to build a cool company. 2. The workNVIDIA is known for hardware, but they also have a strong software engineering team. My manager lets me choose what I want to work on. The work ranges from research to large-scale production, so there are plenty of projects for me to choose from. My work is not restricted to a tiny piece of code, and I can be the owner of a project. I can also work with people from other teams. Once, I was impressed with someone’s work and he was on another team. I reached out to him and we did a project together. I realized that I loved my work at NVIDIA when one Saturday, I suddenly had the urge to come to the office to finish some experiments. I have never felt bored at work. There is always something to work on or someone to talk to. I’m learning so much. 3. The impactUnlikely many big companies, NVIDIA managers share the company’s strategy with their staff. Even as a low-level engineer, I feel like I know where the company is headed. NVIDIA is ambitious. They offer many projects with huge potential. I can make a difference with the project I’m working on. The managers watch out for your work and make sure they get the attention they deserve. I once volunteered to do something for the company and my work got detailed feedback from one VP and two senior directors. This is unlikely to happen at other big companies. 4. The fightThe hardware competition is red hot right now. Every tech giant seems to want to a piece of it. Working at NVIDIA gives me a front-row seat to watch it unfold. When I asked my manager why he moved here from Apple, he said it’s because of “the fight”. For some reason I haven’t been able to internalize, being part of NVIDIA seems heroic. I want to do my best to help NVIDIA win the fight. Some people might ask: what about the pay? Did money really not factor in my thought process at all? It’d be a lie to say I wasn’t tempted when someone mentioned their 6-figure sign on bonus fresh out of their master’s program. Like many of peers, I have the goal of one day having enough money to never have to work for money. But for now, working in tech, I know that whatever job I choose will probably pay me well enough. I believe that if I opt for personal growth, one day, I will have a set of skills desirable enough to make more money than I care to spend. Youth is too precious to be sold for money. General advice Know what you’re optimizing for: money, new experiences, prestige, personal growth, or something else? If you don’t know what you want to do, pay attention to what you do in your free time. It’s what you do when nobody is watching that shows your true interests. At least for AI, the line between industry and academia is getting blurrier and blurrier. Don’t fret about PhD or no PhD. You can always start your PhD and then drop out, or apply for a PhD after a few years in industry. Publish your code on GitHub and invest your time to build some decent GitHub repos. I’ve had more than one company that offered me a job because they were impressed with my GitHub. Don’t freak out about your GPA. If you think it’s low (e.g. &lt; 3.3), just don’t put it on your resume. As long as you have a decent technical background (e.g. past internships + side projects + GitHub), nobody cares about your GPA. During college, intern at both big companies and startups to get a sense of what kind of organization you want to join. The easiest kind of offer you can aim for is an intern-to-full-time conversion offer. The intern interview process can be 3x easier than a full-time interview process. Start your job search early, preferably at the beginning of your senior year. Most of my friends get their full-time offers 2-3 quarters in advance. Early job offers give you peace of mind to be yourself in interviews and leverage to negotiate later. Don’t give up just because you haven’t heard back from some companies. I know people who sent their resumes to hundreds of companies until they got a job. Technical interviews are a pain. Prepare for them a least a month in advance. During interviews, ask about the kind of tasks you’ll do in the role, the manager you’ll report to, and the kind of mentorship you’ll get. Don’t shy away from negotiation. Even if you don’t work for money, you have every right to be paid your worth. In my experience, companies always match offers, even if they say they don’t. I’ve seen two friends with similar experience joining the same company for the same role, but one got $50k more a year because he had a competitive offer. Ask people you admire for their experiences and career advice. Read Glassdoor reviews to get a sense of what you’re getting yourself into. Take some time off between college and your first full-time job, as it’s unlikely you’ll have a vacation again for a long time. If the only reason you stay in a job is the pay, leave. If you don’t find yourself learning in a job, leave. Resist the rat race. Stop comparing yourself to other people. No matter how good you are, there will always be someone who’s better than you at something. Instead, compare you of today with you of yesterday. Be nice. Be kind to yourself. You don’t have to graduate at xx, get a PhD when you’re xx, or become a millionaire when you’re xx. Discover the world. Get to know yourself. Enjoy the process. AcknowledgementsThis post wouldn’t have been possible without long conversations over the year with many people I admire, in both industry and academia. I’d like to thank Christopher Manning, Mykel Kochenderfer, Alexander Rush, Lukasz Kaiser, Laurence Moroney, Danijar Hafner, Lucas Baker, Paul Warren, Jonathan Cohen, Boris Ginsburg, Rex Garland, David Buickians, Dung Ho Chi, and many other friends for putting up with my indecisiveness and unclogging my impossibly dense mind. P/S: If this post makes you interested in learning more about working at NVIDIA, shoot me an email!","link":"/2019/05/26/给最近计算机科学毕业生的职业生涯建议/"}],"tags":[{"name":"学习计划","slug":"学习计划","link":"/tags/学习计划/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hackathon","slug":"hackathon","link":"/tags/hackathon/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"keyboard accelerators","slug":"keyboard-accelerators","link":"/tags/keyboard-accelerators/"},{"name":"presentation","slug":"presentation","link":"/tags/presentation/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"process","slug":"process","link":"/tags/process/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"caffe","slug":"caffe","link":"/tags/caffe/"},{"name":"matlab","slug":"matlab","link":"/tags/matlab/"},{"name":"stylus","slug":"stylus","link":"/tags/stylus/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"面向对象","slug":"面向对象","link":"/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"talk","slug":"talk","link":"/tags/talk/"},{"name":"point cloud","slug":"point-cloud","link":"/tags/point-cloud/"}],"categories":[{"name":"学习计划","slug":"学习计划","link":"/categories/学习计划/"},{"name":"ejs","slug":"ejs","link":"/categories/ejs/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"hachathon","slug":"hachathon","link":"/categories/hachathon/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"keyboard accelerators","slug":"keyboard-accelerators","link":"/categories/keyboard-accelerators/"},{"name":"presentation","slug":"presentation","link":"/categories/presentation/"},{"name":"process","slug":"process","link":"/categories/process/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"icarus","slug":"icarus","link":"/categories/icarus/"},{"name":"caffe","slug":"caffe","link":"/categories/caffe/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"talk","slug":"talk","link":"/categories/talk/"},{"name":"point cloud","slug":"point-cloud","link":"/categories/point-cloud/"}]}