{"pages":[{"title":"关于我","text":"你好，这里是一枚非典型工科生，是硬核且甜甜软软的妹子。在NVIDIA实习中，在成为software engineer的路上挣扎。我喜欢很多领域，音乐剧 / 设计 / 漫画 / 文学，也欢迎安利呀。 教育经历 硕士 software engineer 华东师范大学研究方向：computer vision2019年入学 本科 computer science 华东师范大学2015年入学 感兴趣的专业技能 机器视觉和图像处理 Deep Learning C++ Web 对自己读研的期望是能成为工程能力很强的researcher～加油！ 联系我 在blog留言 QQ: 707767931 Wechat: Angericky Email: jingjingbudlet@gmail.com / presente_de_deus@163.com 涉足无人抵达的远方就能摘取星星上的金子。","link":"/about/index.html"},{"title":"设计集collection","text":"大学时期制作的海报找不太到了，放上追星途上为爱发电的一些拙劣之作，也算是纪念年少青春的闲暇时光～这辈子的水平大概也就止于对优秀的平面设计作品欣赏啦。","link":"/collection/index.html"}],"posts":[{"title":"C++开发学习计划","text":"这一年，领悟到无论是出国/保研/考研/就业的道路，我们都应该拓宽横向比较的世界，不局限在身边的人，要去看更多优秀的人是怎么做的，这种借鉴能让我避免处在井底之蛙的境地，对信息搜集和个人成长都大有益处。时光无法补救，已经蹉跎到大四了，既然意识到积累太少，就更应该补上专业方面的知识，将书读薄再读厚。 前言即将踏入2019年实习阶段。在面试了几次才知道自己有多菜，但每一次面试都会发现自己的不足，可以有针对性地查漏补缺，因此有面试经历真是很棒。 发现如果早点开始做就业准备，一定可以拿到比较喜欢的offer，而我的大三大四就不会显得这么被动，以至于往读研方向发展没有退路。 成绩好就是学习好的认识太狭隘了。说课业紧张而不去实习，其实是自我管理和学习效率不够，时间是海绵里的水，挤挤总是有的。 这一年，领悟到无论是保研还是就业的道路，我都应该拓宽横向比较的世界，不局限在身边的人，要去看更多优秀的人是怎么做的，这种借鉴能让我避免处在井底之蛙的境地，对信息搜集和个人成长都大有益处。 时光无法补救，已经蹉跎到大四了，既然意识到积累太少，就更应该补上专业方面的知识，将书读薄再读厚。 需要读的书/掌握的知识C++ Effective C++ More Effective C++ STL源码解析 对象模型 C++ Primer Plus C++ Primer 操作系统 操作系统概论 现代计算机操作系统（这本书是讲操作系统的 深入理解计算机操作系统（这本书是讲程序在操作系统中处理的） 计算机网络 计算机网络第六版谢仁希 tcp/ip详解 数据结构 哈希表实现，冲突解决方法 AVL树、红黑树 哈夫曼编码 算法 常用排序算法、复杂度计算、查找、DFS、BFS 记忆化搜索、DP 最短路算法 字符串相关的(如：KMP、BM等）。 线段树 编译原理 DFA、NFA 解决二义性的方法 解决移进/规约冲突 设计模式 大话设计模式 设计模式解析第二版 每个设计模式做小demo并备份 暂时就列这些，利用上班通勤和其他碎片时间慢慢读～","link":"/2018/12/26/C-开发学习计划/"},{"title":"EJS里判断一个变量是否可用","text":"改博客时候遇到的问题：ejs互相传参数，怎么得知参数有没有被传呢？ 问题描述node代码里存在两种情况：12res.render(&apos;home/content&apos;, { detail:detail,list:list } );res.render(&apos;home/content&apos;, { detail:detail } ); EJS:123&lt;% if(list==undefined){ %&gt; &lt;span&gt;暂时没有内容&lt;/span&gt;&lt;% } %&gt; 当node里不提供list的时候，页面判断list是否存在的时候报错12345678ReferenceError: D:\\demo\\views\\home\\content.ejs:10 8| &lt;/div&gt; 9| &lt;/div&gt;&gt;&gt; 10| &lt;% 11| if(list==undefined){ 12| 13| }list is not defined 这时候怎么办？难道必须在node里添加一个list为空的变量过来吗？还是有在EJS里有其他验证方法？ 解决方法123if(locals.list==undefined){ ...} 用到EJS的locals就可以防止报错啦～","link":"/2019/01/12/EJS里判断一个变量是否可用/"},{"title":"O(n)算法查找第k大的数","text":"面试中常见的经典算法题：O(n)算法查找第k大的数。 O(n)算法查找第k大的数思路这里讲利用快速排序Partion的算法，核心思想是快排的分支算法，具体思路： 利用快排的partion函数将数组分成左右两个部分 如果位置p刚好等于k，则说明p位置的数，就是我们要找的数，如果分出来的边界位置p小于给定的数k，我们知道最小的第k个数，肯定在p的右边，如果p大于给定的k则在p边界的左边 递归在p的左边或者右边查找 注：p为数组下标需要加1。 具体的细节可以查看《算法导论》第九章，下面是简单的实现代码。 复杂度对于快速排序，算法复杂度是O(N * logN)。而这个算法的算法复杂度是O(N)。为什么呢？其实这个地方的算法复杂度分析很有意思。 第一次交换，算法复杂度为O(N)，接下来的过程和快速排序不同，快速排序是要继续处理两边的数据，再合并，合并操作的算法复杂度是O(1)，于是总的算法复杂度是O(N * logN)（可以这么理解，每次交换用了N，一共logN次）。 但是这里在确定枢纽元的相对位置（在K的左边或者右边）之后不用再对剩下的一半进行处理。也就是说第二次插入的算法复杂度不再是O(N)而是O(N/2)。？接下来的过程是1+1/2+1/4+…….. &lt; 2，换句话说就是一共是O(2N)的算法复杂度也就是O(N)的算法复杂度。 代码递归实现123456789101112131415161718192021class Solution {public: int partion(vector&lt;int&gt; &amp;nums,int k,int start, int end){ int tmp = nums[start], n = nums.size(), left = start, right = end; while(left &lt; right){ while(right &gt; left &amp;&amp; nums[right] &lt; tmp) right --; if(right &gt; left) nums[left ++] = nums[right]; while(left &lt; right &amp;&amp; nums[left] &gt;= tmp) left ++; if(left &lt; right) nums[right --] = nums[left]; } nums[left] = tmp; if(left == k - 1) return tmp; else if(left &gt; k - 1) return partion(nums, k, start, left - 1); else return partion(nums, k, left + 1, end); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { return partion(nums, k, 0, nums.size() - 1); }}; 非递归实现12345678910111213141516171819202122232425262728293031static auto sycn_false = [](){ ios :: sync_with_stdio(false); cin.tie(nullptr); return nullptr;}();class Solution {public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int start = 0, end = nums.size() - 1; while(start &lt;= end){ int tmp = nums[start], left = start, right = end; while(left &lt; right){ while(left &lt; right &amp;&amp; nums[right] &lt; tmp) right --; if(left &lt; right){ nums[left ++] = nums[right]; } while(left &lt; right &amp;&amp; nums[left] &gt;= tmp) left ++; if(left &lt; right){ nums[right --] = nums[left]; } } nums[left] = tmp; if(left == k - 1) return nums[left]; else if(left &gt; k - 1) end = left - 1; else start = left + 1; } return -1; }};","link":"/2018/12/26/O-n-算法查找第k大的数/"},{"title":"Vue学习总结","text":"xmind + 笔记，整理细碎的知识点。 Vue.js是什么Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用（SPA）提供驱动。需要理解的是，Vue的一个核心思想是数据驱动，组件与组件之间只有数据交换。对于视图的修改，不会直接操作DOM，而是通过修改数据。交互复杂时，只关心数据修改会让代码逻辑变得很清晰，不用碰触DOM，这样的代码非常利于维护。 Vue知识体系这是我自己根据官方文档在思维导图上构建的知识体系。 生命周期什么是生命周期 Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。 在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册js方法，可以让我们用自己注册的js方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。 生命周期图及标注 特别值得注意的是created钩子函数和mounted钩子函数的区别 生命周期钩子函数beforeCreate 在实例初始化后，数据观测(data observer)和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下配置：数据观测(data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的render函数首次被调用。 mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。 beforeUpdate 数据更新时调用，发生在虚拟DOM重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 destroyed Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vuex是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。","link":"/2019/03/10/Vue学习总结/"},{"title":"gitlab与github","text":"两者都是用git实现代码托管的版本仓库，两者很相似，那它们的区别是？ 简介相比于GitHub，GitLab更适合企业级使用，为企业搭建GitLab软件版本管理服务器。 GitLab：https://about.gitlab.com/GitHub: https://github.com/ GitLab利用Ruby on Rail开发的开源应用程序，实现一个自托管的Git项目仓库，可以通过web界面进行访问公开的或者私人项目。Ruby on Rail是一个使你开发、部署、维护web应用程序变得简单的框架。GitLab拥有与GitHub类似的功能，能够浏览源代码，管理缺陷和注释，可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库，它提供一个代码片段功能可以轻松实现代码复用，便于日后有需要的时候进行查找。 GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git作为唯一的版本库格式进行托管，故名GitHub。 两者区别相同点二者都是基于web的Git仓库，在很大程度上GitLab是仿造GitHub来做的，他们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。 不同点： GitHub如果使用私有仓库，是需要付费的，GitLab可以在上面搭建私人的免费仓库 GitLab让开发团队对他们的代码仓库拥有更多的控制，相对于GitHub，它有不少的特色： 允许免费设置仓库权限 允许用户选择分享一个project的部分代码 允许用户设置project的获取权限，进一步提升安全性 可以设置获取到团队整体的改进进度 通过innersourcing让不在权限范围内的人访问不到该资源 gitlab安装及使用： 关闭防火墙和selinux，并安装安装依赖的包 12345systemctl stop firewalld &amp;&amp; systemctl disable firewalldsetenforce 0 并修改/etc/selinux/config yum -y install openssh-server postfix yum install -y curl policycoreutils-python openssh-server 启动positfix和sshd 12systemctl enable postfix &amp;&amp; systemctl start postfixsystemctl enable sshd &amp;&amp; systemctl start sshd 下载安装包并安装安装包 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash 打开/etc/gitlab/gitlab.rb,将external_url = 'http://git.example.com'修改为自己的IP地址：http://xxx.xx.xxx.xx,然后执行下面的命令，对GitLab进行编译。 sudo gitlab-ctl reconfigure 登录GitLab Username: root Password: 5iveL!fe GitLab管理 gitlab-ctl start/stop/restart/reconfigure git相关概念： git 是一种版本控制系统，是一个命令，是一种工具 gitlib 是基于git功能的开发库 github 是一个基于git实现在线代码托管的仓库，包含一个网站界面，向互联网开放 gitlab 是一个基于git实现的在线代码仓库托管软件，一般用于在企业内搭建git私服git-ce是社区版，gitlab-ee是企业版，收费版","link":"/2019/02/22/gitlab与github/"},{"title":"git修改已提交的备注","text":"用rebase修改github上历史修改的备注。 最后一次提交的注释1git commit --amend 然后在出来的编辑界面，直接编辑注释的信息,保存退出。 更早之前的历史修改假设要修改当前版本往前三次版本的状态,四次就把HEAD~3改成HEAD~4,以此类推/1git rebase -i HEAD~3 假设要从第一个版本开始修改，1git rebase -i --root 然后会看到，123pick sha1 Xpick sha1 Ypick sha1 Z 要修改哪个,就把那行的pick改成edit，123pick sha1 Xedit sha1 Ypick sha1 Z :wq保存并退出。通过git log查看历史，可以发现git的最后一次提交已经变成刚才选的那个了然后就和修改最后一次提交一样了1git commit -amend 修改完了之后,这样返回1git rebase --continue 这时候就又回到正常状态了 压缩掉不需要的版本和上面一个修改历史差不多，也是使用git rebase同样会看到123pick sha1 Xpick sha1 Ypick sha1 Z 不同的是要压缩掉哪个版本,就把那个版本pick改成squash123pick sha1 Xsquash sha1 Ypick sha1 Z 保存退出,会出现备注,再次保存退出。用git log查看那个备注为Y的版本已经没了。","link":"/2019/01/02/git修改已提交的备注/"},{"title":"Google Girl Hackathon 2019赛后感","text":"很幸运拿到了Dream Company这次girl hackathon的门票。在周五到周末三天的小组团队项目比赛里，我们组DeliveryGo拿到了Best Team Top 2，很开心～ 2019年，分别到了我最喜欢的软件和硬件公司体验了一下，非常幸运。 Google Shanghai的地理位置也太好了吧，居然在环球金融中心，左拥金茂大厦，右抱东方明珠。不过陆家嘴上下班时间有点挤。Google Shanghai的食堂还不错，是自助餐式的，如果天天在这里吃这种健康的食物，我一定会变瘦的。周末给我们订的外卖也不错，准备的零食也很充分，抹茶糯米团真好吃。 HR小哥哥Brett的酒窝好甜哦！呜呜呜，过去social发现是校友，真好。逛了一圈office，发现工位没有我们NVIDIA的大（骄傲脸）。（对不起，主题跑偏了） 这次girl hackathon的项目里，我和本系学妹以及浙大的三个姑娘组成了一个五人团队，根据题目起的队名叫DeliveryGo（模仿alphaGo），另外几个妹子主要看算法，只有我懂一点JS，所以只好挑起做前端的大梁啦。 我主要做了web的路径规划可视化，已经放到我github的repository里了，UI挺好看的，也感谢队友们一起设计、找图和PS的努力。 48小时里写出来这样的demo，我发现自己的学习速度超乎预期，没想到能写这么快，看来在NV实习的一个月的成长还是挺快的，不仅是关于前端的知识，还有自学的能力。我对自己更有信心了。 从算法结果、Demo、pre三方面打分，最后我们拿到了Best team top 2。是很棒的结果，谢谢队友们的共同努力，前一天通宵的努力是有收获的。 没拿到Best team top one，挺可惜的，可能是因为操作失误，我们组的算法结果交错了几组，没拿到最好的performance and efficiency。Presentation展示Demo的时候，也有其他组做了的UI很好。有点难过，这种不甘心大概也能更好地驱动我继续学习，努力向前走吧。 谢谢nowcoder以及Google提供的这次机会，我是一个容易被鼓励但会很轻易怀疑自己的人，这个活动对我的激励真的很大。 (顺带一提，google奖品里给的包真的很不错，这个安卓机器人模型也很可爱！) 有点后遗症，由于长时间盯着电脑，肩膀和脖子不舒服了两三天，做这行还是要多健身多运动呀～","link":"/2019/03/18/google-girl-hackthon-2019赛后感/"},{"title":"Hello World","text":"This is jingjing’s very first post. There is some information about hexo. Welcome to Hexo! This is jingjing’s very first post.Hello world~Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/12/22/hello-world/"},{"title":"网页的跳转页面及参数传递方法","text":"两者都是用git实现代码托管的版本仓库，两者很相似，那它们的区别是？ 跳转页面 直接在跳转的内容外部加上 html加参数onclick=”function()”function里写window.open(&quot;url&quot;, _self/__blank(default);或者 12window.location.href=&quot;url&quot;;window.history.back(-1); 参数传递： url传参：第一个页面(a.html)： 1234var obj = a.value; //传给弹出页面参数var url = &apos;jxb.html?obj=&apos;+obj;url = encodeURI(url);window.open(url, &quot;&quot;, &quot;width=600,height=400&quot;); 第二个页面(b.html)： 1234var url = decodeURI(window.location.href);var argsIndex = url .split(&quot;?obj=&quot;);var arg = argsIndex[1]; 注:中文传输:可以在页面a用encodeURI 编码url 在b页面用decodeURI解码url cookie传参(不能跨域)： 1234567function setCookie(cname,cvalue){ document.cookie = cname + &quot;=&quot; + cvalue;}function getCookie(cname){ var name = cname + &quot;=&quot;; var ca = document.cookie;}` localStorage对象传参： 1234567a.html：var div = doucment.getElementById(&apos;要获取字符串的DIV ID名&apos;);localStorage.string = div.textContent;b.html：var div = doucment.getElementById(&apos;要写入的DIV ID名&apos;);div.textContent = localStorage.string; window.opener() 父页面： 12&lt;input type=&quot;text&quot; name=&quot;textfield&quot; id=&quot;textfield&quot;/&gt;window.open(&quot;子页面.html&quot;); 子页面： 1window.opener.document.getElementByIdx(&apos;textfield&apos;).value=&apos;123123123&apos;; 如果跨域，子页面还要加上document.domain=”父页面url”","link":"/2019/03/05/html跳转页面的参数传递/"},{"title":"vue-router传递参数params和query的区别","text":"如题。 比较用法1. 用法query要用path来引入，params要用name来引入(当你使用params方法传参的时候，要在路由后面加参数名)，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。如果传参时未定义name，则获取不到params。 路由界面1234567&lt;router-link :to=\"{ name: 'router1', path: 'Hello', params: { id: 'menuIndex' }, query: { id: 'menuIndex' } }\"&gt;&lt;button&gt;Go to Foo&lt;/button&gt;&lt;/router-link&gt; 2. url地址显示query更加类似于我们ajax中get传参，params则类似于post，说得简单一些，即前者在浏览器地址栏中显示参数，后者则不显示。 queryhttp://localhost:8080/workorder/newApply?type=BOX_DEPLOY&amp;typeDesc=%E5%B0%8F%E7%99%BD%E7%9B%92%E9%83%A8%E7%BD%B2 paramshttp://localhost:8080/workorder/newApply 3. 注意点query刷新不会丢失query里面的数据params刷新会丢失params里面的数据","link":"/2019/03/03/vue-router传递参数params和query的区别/"},{"title":"常用快捷键和指令","text":"包括但不限于vim和Linux命令。 网页开发者工具 打开/关闭chrome + safari mac: opt + command + i win: F12 ctrl + shift + i/j 截屏快捷键 mac: command + shift + 3，全屏自动保存到桌面 command + shift + 4，鼠标框选需要截图的地方，自动保存到桌面 space键可以移动这个区域 shift键可以锁定x/y轴进行拖动 option键能按照区域圆心进行放大 win: Win + Shift+ S， 截图自动保存到剪贴板 Vim12345678910111213141516171819202122232425262728293031ctrl + f # 屏幕『向下』移动一页ctrl + b # 屏幕『向上』移动一页n + [space](n为数字，space空格键) # 按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20[space] 则光标会向后面移动 20 个字符距离。0 # 这是数字『 0 』：移动到这一行的最前面字符处$ # 移动到这一行的最后面字符处G # 移动到这个档案的最后一行nG # n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行n + [Enter] # n 为数字。光标向下移动 n 行dd # 删除游标所在的那一整行ndd # n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行yy # 复制游标所在的那一行nyy # n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行set nu # 设置显示行号set nonu # 设置不显示行号ctrl + z #最小化fg # 恢复最小化 Linux命令 df 显示磁盘统计空间12345678df -h文件系统 容量 已用 可用 已用% 挂载点/dev/vda1 40G 5.3G 32G 15% /devtmpfs 909M 0 909M 0% /devtmpfs 920M 0 920M 0% /dev/shmtmpfs 920M 444K 919M 1% /runtmpfs 920M 0 920M 0% /sys/fs/cgrouptmpfs 184M 0 184M 0% /run/user/0 free 于显示内存状态1234free -mtotal used free shared buff/cache availableMem: 1838 265 981 0 591 1395Swap: 2047 0 20 查看linux ip地址 ip addr show | grep inet | awk ‘{ print $2; }’ | sed ‘s/\\/.*$//‘ find命令查找最近修改过的文件 按时间查找也有参数 -atime 访问时间 -ctime 改变状态的时间 -mtime修改的时间。但要注意，这里的时间是以24小时为单位的。查看man手册后使用，你会很迷惑： -mtime n： Files data was last modified n*24 hours ago. 字面上的理解是最后一次修改发生在n个24小时以前的文件，但实际上 12find ./ -mtime 0：返回最近24小时内修改过的文件。find ./ -mtime 1 ： 返回的是前48~24小时修改过的文件。而不是48小时以内修改过的文件。 那怎么返回10天内修改过的文件？find还可以支持表达式关系运算，所以可以把最近几天的数据一天天的加起来： find ./ -mtime 0 -o -mtime 1 -o -mtime 2 …… 另外， -mmin参数-cmin / - amin也是类似的。 win打开我的电脑Win + E","link":"/2019/02/22/常用快捷键/"},{"title":"hexo及icarus主题个性定制","text":"icarus个性定制配置修改的一些内容。 前言此篇不介绍hexo的搭建，网上教程已经很完善，这里讲我用icarus做的一些个性化配置。 语言切换Icarus提供多语言切换，默认是英文的。为了改成中文，进入项目目录，修改_config.yml 中的language: zh-CN 增加文章字间距icarus中文显示字体有点挤。在icarus/xiansource/css/style.styl中.article .content的部分加上letter-spacing: 0.08rem; 加宽中心文章的布局icarus默认的文章区域比较窄，我想改得宽一点，突出文章内容。解决办法： 打开themes/icarus/layout/layout.ejs 改变main_column_class()中case 3的返回值 原值为is-8-tablet is-8-desktop is-6-widescreen 我改成了is-10-tablet is-10-desktop is-8-widescreen 但是重新部署的时候，会出现整体内容不居中解决办法：通过开发者工具可以看到生成的container.saas文件里，margin-left和margin-right都是auto在icarus/source/css/style.sytl中加上属性12345678910111213141516171819 .container margin-left: 2rem; margin-right: 2rem;``同时为了让navbar居中把在同一个文件中@media screen and (mid-width: screen-fullhd)的部分里把@media screen and (min-width: screen-fullhd) 部分改成```css @media screen and (min-width: screen-fullhd) .is-3-column .container max-width: 1600px margin-left: 2rem; margin-right: 2rem; .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap margin-left: auto; margin-right: auto; .is-1-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap 更改友情链接布局icarus本身的链接布局是一列一列的，左边昵称，右边链接。我为了省空间，把跳转链接直接加到昵称上，让两个昵称左右分布。更改links.ejs文件里div class=&quot;card-content&quot;部分123456789101112131415161718192021222324&lt;div class=\"menu links\"&gt; &lt;h3 class=\"menu-label\"&gt; &lt;%= __('widget.links') %&gt; &lt;/h3&gt; &lt;ul class=\"menu-list\"&gt; &lt;% let flag = 1; for (let i in links) { %&gt; &lt;% if (flag == 1) { %&gt; &lt;li&gt; &lt;a class=\"level is-mobile\" href=\"&lt;%- links[i] %&gt;\" target=\"_blank\"&gt; &lt;span class=\"level-left\" style=\"text-decoration: underline\"&gt; &lt;span class=\"level-item\"&gt;&lt;%= i %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;% flag = 0;} else {%&gt; &lt;a class=\"level is-mobile\" href=\"&lt;%- links[i] %&gt;\" target=\"_blank\"&gt; &lt;span class=\"level-right\" style=\"text-decoration: underline\"&gt; &lt;span class=\"level-item\"&gt;&lt;%= i %&gt;&lt;/span&gt; &lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;% flag = 1;} %&gt; &lt;% } %&gt; &lt;/ul&gt;&lt;/div&gt; style.style中widget部分改为123456789101112.widget .media border: none .media + .media margin-top: 0 .menu-list li ul margin-right: 0 a.level display: flex .links .menu-list a.level display: inline-block 给博客增加自定义目录在article.ejs中添加123456789&lt;div class=\"content\"&gt; &lt;% if(!index &amp;&amp; post.ttoc == true){ %&gt; &lt;div id=\"toc\" class=\"toc-article\"&gt; &lt;strong class=\"toc-title\"&gt;文章目录&lt;/strong&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;% } %&gt; &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt;&lt;/div&gt; 对于需要添加目录的博客，在header中添加ttoc: true 为博客增加分享功能icarus提供多个分享插件。 AddThis AddToAny Baidu Share Share.js ShareThis 我选择share.js插件，它可以一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等社交网站。设置步骤：123_config.ymlshare: type: sharejs 给blog增加点击爱心效果创建js文件在/themes/icarus/source/js/src下新建文件clicklove.js，接着把该链接下的代码拷贝粘贴到clicklove.js文件中。123456789101112131415161718192021222324252627282930313233343536373839404142!function(e,t,a){ function n(){ c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"), o(), r() } function r(){ for(var e=0;e&lt;d.length;e++) d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\"); requestAnimationFrame(r) } function o(){ var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick; e.onclick=function(e){ t&amp;&amp;t(),i(e) } }function i(e){ var a=t.createElement(\"div\"); a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a) } function c(e){ var a=t.createElement(\"style\");a.type=\"text/css\"; try{ a.appendChild(t.createTextNode(e)) } catch(t){ a.styleSheet.cssText=e } t.getElementsByTagName(\"head\")[0].appendChild(a) } function s(){ return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\" } var d=[]; e.requestAnimationFrame=function(){ return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){ setTimeout(e,1e3/60) } }(), n()}(window,document); 修改layout.ejs文件在/theme/icarus/layout/layout.ejs的&lt;!DOCTYPE html&gt;之后增加语句1&lt;script src=\"/js/clicklove.js\"&gt;&lt;/script&gt; 增加看板娘插件live2D安装使用 npm 安装：在 Hexo 项目的根目录运行命令：1npm install --save hexo-helper-live2d 3.0.1 版本存在的 bug：存在代码注入 bug，与 hexo-tag-dplayer 插件产生冲突，导致相关脚本无法加载。解决方法：在项目中使用 npm 命令手动卸载 “hexo-tag-dplayer”: “^0.3.1”。参阅GitHub issue 给文章日期/分类/标签增加图标Icarus主题下的这些没有图标，但我想加图标的话怎么办？hexo里可以使用FontAwesome图标CSS样式加上字体库实现图标的引用。其它网站开发中也可以使用。 引入Icarus主题源文件中已经引用了CSS文件，可直接跳过这部分。 使用图标之前需要引入 CSS 文件,这里选用 FontAwesome 4.4.0 版本。1&lt;link href=\"//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css\" rel=\"stylesheet\"&gt; 当然,还可以使用离线包,我们可以去官网下载它。http://fontawesome.io/ 使用1&lt;i class=\"fa fa-home\"&gt;&lt;/i&gt; 图标CSS清单可参考博客 文章做成两格布局文件改动includes/helpers/layout.js中12hexo.extend.helper.register(&apos;column_count&apos;, function () { let columns = 1; 后添加123if (this.page.__post === true || this.page.__page === true) { return 2;} layout/common/widget.ejs中1&lt;%- partial('common/widget', { position: 'right' }) %&gt; 改成123&lt;% if (page.__page !== true &amp;&amp; page.__post !== true) { %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt;&lt;% } %&gt; layout/layout.ejs中hexo.extend.helper.register('column_count', function () { let columns = 1;后添加123 if (this.page.__post === true || this.page.__page === true) { return 2;} 但这样左边栏显示变宽了，我觉得不是很好看，怎么办呢？ 把layout/common/widget.ejs中side_column_class()的case 2的返回值改成return 'is-4-tablet is-4-desktop is-3-widescreen';就好啦！ 更多细则可以参考作者项目的issue(作者是个勤于回复的人！特别好！) 添加文章更新时间 修改（博客主目录/themes/icarus/layout/common/article.ejs文件，在&lt;time class=&quot;level-item has-text-grey&quot; datetime=&quot;&lt;%= date_xml(post.date) %&gt;&quot;&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;标签后添加 1234&lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt; &lt;i class=\"fas fa-calendar-check\"&gt;&amp;nbsp&lt;/i&gt; &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.updated) %&gt;\"&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;&lt;% } %&gt; 根据博客配置文件中的 language 参数修改对应的语言配置文件（博客主目录）/themes/icarus/languages/zh_CN.yml 12post: updated: 更新于 修改主题配置文件（博客主目录）/themes/icarus/_config.yml，增加一行 1display_updated: true 写文章的时候可以直接在文章开头设置更新时间updated: 2018-01-01 12:00:00没有这参数的话将会显示md文件的修改日期 优化访问速度To be continued…","link":"/2018/12/24/icarus个性定制/"},{"title":"markdown基本语法","text":"Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。 Markdown 为记录思想和分享知识提供更专业的工具。 可以使用 Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法需要在#后跟个空格再写文字。 示例： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题字体 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 示例： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 效果如下：这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;直到n个 示例： 这是引用的内容 这是引用的内容 这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 分割线三个或者三个以上的 - 或者 * 都可以。 示例： 效果如下： 可以看到，显示效果是一样的。 图片语法： 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 效果如下： 超链接语法：超链接名title可加可不加 示例： hexogithub 效果如下：hexogithub 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 超链接名 示例Github 列表 无序列表语法：无序列表用 - + * 任何一种都可以 列表内容 列表内容 列表内容 注意：- + * 跟内容之间都要有一个空格 列表内容 列表内容 列表内容 有序列表语法：数字加点 1.列表内容2.列表内容3.列表内容 注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 表格语法： 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。-有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 代码语法：单行代码：代码之间分别用一个反引号包起来 代码内容 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行(12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 代码... 代码... 代码...(```)注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。示例：单行代码&gt; `create database hero;`代码块&gt; (```)&gt; function fun(){&gt; echo &quot;这是一句非常牛逼的代码&quot;;&gt; }&gt; fun();&gt; (```)效果如下：单行代码`create database hero;`代码块function fun(){ echo &quot;这是一句非常牛逼的代码&quot;;}fun();### 流程图### 制作一份待办事宜 [Todo 列表](https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表)- [ ] 支持以 PDF 格式导出文稿- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率- [x] 新增 Todo 列表功能- [x] 修复 LaTex 公式渲染问题- [x] 新增 LaTex 公式编号功能### 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$### 高亮一段代码[^code]```python@requires_authorizationclass SomeClass: passif __name__ == &apos;__main__&apos;: # A comment print &apos;hello world&apos; 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","link":"/2018/12/22/markdown基本语法/"},{"title":"关于我和3DGNN论文及源码的爱恨情仇","text":"配这篇论文源码的环境的过程实在是太艰难了。也 太 艰 难 了。究竟是什么样的狠人才会用matlab + caffe的环境啊！！ 预先配好的环境：Ubuntu 16.04(64bit) cuda: 8.0 cudnn: 5.1 Matlab: R2015b OpenCV: 3.4.3 显卡: GeForce 1080Ti x2 安装caffemake all -j8 make test -j8 make runtest -j8 错误信息: 找不到hdf5 fatal error: hdf5.h: No such file or directory 解决办法一在caffe文件夹下的MakeFile.configINCLUDE_DIRS := 最后加上 /usr/include/hdf5/serial/LIBRARY_DIRS := 最后加上 /usr/lib/x86_64-linux-gnu/hdf5/serial/保存，重新编译即可。 解决办法二（如果有root权限）增加软连接：cd /usr/lib/x86_64-linux-gnusudo ln -s libhdf5_serial.so.8.0.2 libhdf5.sosudo ln -s libhdf5_serial_hl.so.8.0.2 libhdf5_hl.so 错误信息：找不到-lhdf5 LD -o .build_release/lib/libcaffe.so.1.0.0-rc3/usr/bin/ld: cannot find -lhdf5collect2: error: ld returned 1 exit statusMakefile:563: recipe for target ‘.build_release/lib/libcaffe.so.1.0.0-rc3’ failedmake: *** [.build_release/lib/libcaffe.so.1.0.0-rc3] Error 1 解决办法：改Makefile里LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_serial_hl hdf5_serial 错误信息：关于cudnn In file included from ./include/caffe/util/device_alternate.hpp:40:0, from ./include/caffe/common.hpp:19, from src/caffe/common.cpp:7:./include/caffe/util/cudnn.hpp: In function ‘void caffe::cudnn::createPoolingDesc(cudnnPoolingStruct, caffe::PoolingParameter_PoolMethod, cudnnPoolingMode_t, int, int, int, int, int, int)’:./include/caffe/util/cudnn.hpp:127:41: error: too few arguments to function ‘cudnnStatus_t cudnnSetPooling2dDescriptor(cudnnPoolingDescriptor_t, cudnnPoolingMode_t, cudnnNanPropagation_t, int, int, int, int, int, int)’ pad_h, pad_w, stride_h, stride_w)); ^./include/caffe/util/cudnn.hpp:15:28: note: in definition of macro ‘CUDNN_CHECK’ cudnnStatus_t status = condition; \\ ^In file included from ./include/caffe/util/cudnn.hpp:5:0, from ./include/caffe/util/device_alternate.hpp:40, from ./include/caffe/common.hpp:19, from src/caffe/common.cpp:7:/usr/local/cuda-7.5//include/cudnn.h:803:27: note: declared here cudnnStatus_t CUDNNWINAPI cudnnSetPooling2dDescriptor( ^make: [.build_release/src/caffe/common.o] Error 1 参考链接(https://blog.csdn.net/u011070171/article/details/52292680)[https://blog.csdn.net/u011070171/article/details/52292680] 这是因为当前版本的caffe的cudnn实现与系统所安装的cudnn的版本不一致引起的。 解决办法(害怕自己有失误的宝宝要记得备份哦)： git clone最新版本的caffe源码 将./include/caffe/util/cudnn.hpp 换成最新版的caffe里的cudnn的实现，即相应的cudnn.hpp. 将./include/caffe/layers里的，所有以cudnn开头的文件，例如cudnn_conv_layer.hpp。 都替换成最新版的caffe里的相应的同名文件。 将./src/caffe/layers里的，所有以cudnn开头，以.cpp或者.cu结尾的文件，例如cudnn_lrn_layer.cu，cudnn_pooling_layer.cpp，cudnn_sigmoid_layer.cu，都替换成最新版的caffe里的相应的同名文件。 错误信息：cannot find -lopencv_dep_cudart /usr/bin/ld: cannot find -lopencv_dep_cudartcollect2: error: ld returned 1 exit statussrc/caffe/CMakeFiles/caffe.dir/build.make:4285: recipe for target ‘lib/libcaffe.so.1.0.0-rc3’ failedmake[2]: [lib/libcaffe.so.1.0.0-rc3] Error 1CMakeFiles/Makefile2:272: recipe for target ‘src/caffe/CMakeFiles/caffe.dir/all’ failedmake[1]: [src/caffe/CMakeFiles/caffe.dir/all] Error 2Makefile:127: recipe for target ‘all’ failedmake: *** [all] Error 2 解决办法：需要在bash里set CUDA_USE_STATIC_CUDA_RUNTIME=off，再make 错误信息：make的时候libcaffe.so出错 undefined reference to cv:: .build_release/lib/libcaffe.so: undefined reference to `cv::_InputArray::_InputArray(cv::Mat const&amp;)’ .build_release/lib/libcaffe.so: undefined reference to `cv::imdecode(cv::_InputArray const&amp;, int)’ .build_release/lib/libcaffe.so: undefined reference to `cv::imencode(std::__cxx11::basic_string&lt;char, std::char_traits, std::allocator &gt; const&amp;, cv::_InputArray const&amp;, std::vector&lt;unsigned char, std::allocator &gt;&amp;, std::vector&lt;int, std::allocator &gt; const&amp;)’ .build_release/lib/libcaffe.so: undefined reference to `CvKNearest::CvKNearest(CvMat const, CvMat const, CvMat const*, bool, int)’ ………………………………. collect2: error: ld returned 1 exit status Makefile:616: recipe for target ‘.build_release/tools/compute_image_mean.bin’ failed make: *** [.build_release/tools/compute_image_mean.bin] Error 1 出现这样的问题是因为caffe没有找到库。 可能原因： 使用的是opencv3版本需要在Makefile.config里把USE_OPENCV_VERSION := 3的注释去掉，再注释掉USE_PKG_CONFIG := 1。 没找到库路径可以使用LDD .build_release/lib/libcaffe.so查看libcaffe.so链接的动态链接库。如果出现libxxx.so =&gt; not found，则说明是库没找到，或者是原因3。需要先把库路径加在Makefile.config里LIBRARY_DIRS := …后面，再添加你需要的库到Makefile里libraries := …..的后面，即可。 找错了库路径Makefile找库的时候是按照Makefile.config里LIBRARY_DIRS变量值的顺序找的。如果在前面的库路径下存在你需要的库，就不会再从后面的库路径里找了。同样可以使用LDD .build_release/lib/libcaffe.so查看libcaffe.so链接的动态链接库，查看库路径是否正确。如果路径错误，可以对Makefile.config里LIBRARY_DIRS的顺序进行调整。 错误信息：make runtest error in `xxx/test/test.testbin’: free(): invalid pointer在使用caffe run test的时候，如果出现如下报错*** Error in xxx/test/test.testbin': free(): invalid pointer: 0x00007fbaf71accb8 *** 很可能是缺少libtcmalloc-minimal4库，首先安装sudo apt-get install libtcmalloc-minimal4 然后打开~/.bashrc文件vim ~/.bashrc 在文件末尾添加如下代码：export LD_PRELOAD=&quot;/usr/lib/libtcmalloc_minimal.so.4&quot; 最后重新载入环境变量即可source ~/.bashrc 编译及测试matcaffe接口编译matcaffemake matcaffe 测试matcaffe在进行make mattest前，要解决几个编译器版本的问题。 方法1在/usr/local/MATLAB/R2014b/sys/os/glnxa64下把 libstdc++.so.6 重命名为 libstdc++.so.6_backmv libstdc++.so.6 libstdc++.so.6_back这是Matlab找不到libstdc++.so.6之后，会到/usr/lib中找系统用到libstdc++版本 方法2处理这个问题的另外一个办法是建立一个soft link（为一个lib建立一个重定向，以后要找这个名字的lib，会定向到指定的lib那里） 123cd /usr/local/MATLAB/R2016b/sys/os/glnxa64sudo rm libstdc++.so.6sudo ln -s /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.21 libstdc++.so.6 进入matlab注意：caffe路径下生成的matlab folder里应该有+caffe folder，matcaffe需要用到的相关函数实现和文件都在这里。要先addpath('/your_caffe_path/matlan')才能让matlab找到matcaffe，在nyu_crop_data_mask_msc.m里找到gpu_id，选择你的机器上空闲的gpu id。 Terminal里用nvidia-smi指令显示gpu相关信息。 nvidia-smi后显示的信息如下图：123456789101112131415161718192021| NVIDIA-SMI 384.130 Driver Version: 384.130 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce GTX 108... Off | 00000000:17:00.0 Off | N/A || 33% 32C P0 54W / 250W | 0MiB / 11172MiB | 0% Default |+-------------------------------+----------------------+----------------------+| 1 GeForce GTX 108... Off | 00000000:65:00.0 Off | N/A || 33% 35C P0 50W / 250W | 0MiB / 11170MiB | 1% Default |+-------------------------------+----------------------+———————————+ 我这里的GPU序列有0和1，可以设置成gpu_id = 0或者gpu_id = 1。 (注意，matcaffe只能用单gpu训练网络)然后run nyu_crop_data_mask_msc.m，成功。 run matlabscript错误信息：unknown pooling method123456I0331 20:04:23.127297 49968 net.cpp:106] Creating Layer x_1_avepoolI0331 20:04:23.127324 49968 net.cpp:454] x_1_avepool &lt;- out_reduce_out_reduce_relu_0_split_0I0331 20:04:23.127333 49968 net.cpp:454] x_1_avepool &lt;- knn_knn_0_split_0I0331 20:04:23.127346 49968 net.cpp:411] x_1_avepool -&gt; x_1_avepoolF0331 20:04:23.127763 49968 cudnn.hpp:144] Unknown pooling method.*** Check failure stack trace: *** 这是因为源码中并没有用到cudnn。往前看一下输出，可以看到名字是x_1_avepool这层的定义 123456789101112layer { name: \"x_1_avepool\" type: \"Pooling\" bottom: \"out_reduce\" bottom: \"knn\" top: \"x_1_avepool\" pooling_param {​ pool: KNNPOOL​ kernel_size: 11​ pad: 5 }} 所以在util中的cudnn.h里，没有定义KNNPOOL的pooling method。注释掉Makefile.config里的USE_CUDNN即可 cmake错误信息：cmake的make不成功 src/caffe/test/test_gradient_based_solver.cpp:370: FailureThe difference between expected_updated_weight and solver_updated_weight is 1.1920928955078125e-07, which exceeds error_margin, whereexpected_updated_weight evaluates to 9.6857547760009766e-06,solver_updated_weight evaluates to 9.8049640655517578e-06, anderror_margin evaluates to 1.0000000116860974e-07.[ FAILED ] NesterovSolverTest/2.TestNesterovLeastSquaresUpdateWithEverythingShare, where TypeParam = caffe::GPUDevice (8073 ms)[ RUN ] NesterovSolverTest/2.TestLeastSquaresUpdateWithEverythingAccumShare[ OK ] NesterovSolverTest/2.TestLeastSquaresUpdateWithEverythingAccumShare (28 ms)[ RUN ] NesterovSolverTest/2.TestNesterovLeastSquaresUpdateWithEverythingsrc/caffe/test/test_gradient_based_solver.cpp:370: FailureThe difference between expected_updated_weight and solver_updated_weight is 1.1920928955078125e-07, which exceeds error_margin, whereexpected_updated_weight evaluates to 9.6857547760009766e-06,solver_updated_weight evaluates to 9.8049640655517578e-06, anderror_margin evaluates to 1.0000000116860974e-07.[ FAILED ] NesterovSolverTest/2.TestNesterovLeastSquaresUpdateWithEverything, where TypeParam = caffe::GPUDevice (7338 ms) 在make runtest之前，export CUDA_VISIBLE_DEVICES=0 再make runtest 就成功啦。","link":"/2019/03/23/关于我和3DGNN论文及源码的爱恨情仇/"},{"title":"简洁清爽的Stylus语法","text":"Stylus是一个基于Node.js的CSS的预处理框架。其本质上做的事情与sass/less等类似。Stylus比less更强大。icarus主题中用到了stylus。 Stylus介绍Stylus是一个基于Node.js的CSS的预处理框架。可以说是一种新型语言，其本质上做的事情与sass/less等类似。Stylus比less更强大；比sass更符合我们的思路。 它是一个CSS的预处理框架，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，所以 Stylus是一种新型语言，可以创建健壮的、动态的、富有表现力的CSS。比较年轻，其本质上做的事情与 SASS/LESS 等类似，应该是有很多借鉴，所以近似脚本的方式去写CSS代码。 Stylus默认使用 .styl 的作为文件扩展名，支持多样性的CSS语法。 Stylus功能上更为强壮，和js联系更加紧密。 对于开发来说，CSS的弱点在于静态化。我们需要一个真正能提高开发效率的工具，LESS， SASS都在这方面做了一些贡献。 安装全局安装，安装之前你需要先安装nodejs。1$ npm install stylus -g 苹果电脑（mac系统）以上命令或许不成功 mac系统建议以下方式进行安装1$ sudo npm install stylus -g 这样就算是安装完Stylus了，也可以正常使用Stylus。 123456789101112131415161718192021Usage: stylus [options] [command] [&lt; in [&gt; out]] [file|dir ...]Commands: help &lt;prop&gt; Opens help info for &lt;prop&gt; in your default browser. (OS X only)Options: -u, --use &lt;path&gt; Utilize the stylus plugin at &lt;path&gt; -i, --interactive Start interactive REPL -w, --watch Watch file(s) for changes and re-compile -o, --out &lt;dir&gt; Output to &lt;dir&gt; when passing files -C, --css &lt;src&gt; [dest] Convert CSS input to Stylus -I, --include &lt;path&gt; Add &lt;path&gt; to lookup paths -c, --compress Compress CSS output -d, --compare Display input along with output -f, --firebug Emits debug infos in the generated css that can be used by the FireStylus Firebug plugin -l, --line-numbers Emits comments in the generated CSS indicating the corresponding Stylus line -V, --version Display the version of Stylus -h, --help Display help information 生成CSS命令行中建立一个stylusExample/，再在里面建立 src 目录专门存放 stylus 文件，在里面建立 example.styl 文件。然后在 stylusExample 目录下面执行下面命令1$ stylus --compress src/ 输出compiled src/example.css ，这个时候表示你生成成功了，带上–compress参数表示你生成压缩的CSS文件。123$ stylus --css css/example.css css/out.styl CSS转换成styl $ stylus help box-shadow CSS属性的帮助 $ stylus --css test.css 输出基本名一致的.styl文件 应用效果Try Stylus!stylus123body,html margin:0 padding:0 编译成12345body,html { margin: 0; padding: 0;} stylus : 强大的功能丰富的语言1234567891011121314151617181920-pos(type, args) i = 0 position: unquote(type) {args[i]}: args[i + 1] is a 'unit' ? args[i += 1] : 0 {args[i += 1]}: args[i + 1] is a 'unit' ? args[i += 1] : 0absolute() -pos('absolute', arguments)fixed() -pos('fixed', arguments) #prompt absolute: top 150px left 5px width: 200px margin-left: -(@width / 2) #logo fixed: top left 编译成123456789101112#prompt { position: absolute; top: 150px; left: 5px; width: 200px; margin-left: -100px; #logo { position: fixed; top: 0; left: 0;} nibStylus插件stylus123@import 'nib'body background: linear-gradient(20px top, white, black) 编译成1234567body { background: -webkit-linear-gradient(20px top, #fff, #000); background: -moz-linear-gradient(20px top, #fff, #000); background: -o-linear-gradient(20px top, #fff, #000); background: -ms-linear-gradient(20px top, #fff, #000); background: linear-gradient(20px top, #fff, #000);} Nesting(嵌套)stylus123header #logo border:1px solid red 编译成123header #logo { border: 1px solid #f00;} Flexible syntax(灵活的用法)更多详细示例可参考stylus中文文档，或者stylus官方文档。 stylus1234567891011body font 14px/1.5 Helvetica, arial, sans-serif button button.button input[type='button'] input[type='submit'] border-radius 5pxheader #logo,div font-size:14px 编译成123456789101112body { font: 14px/1.5 Helvetica, arial, sans-serif;}body button,body button.button,body input[type='button'] { border-radius: 5px;}header #logo,header div { font-size: 14px;} Flexible &amp;(灵活&amp;)stylus123456789ul li a display: block color: blue padding: 5px html.ie &amp; padding: 6px &amp;:hover color: red 编译成1234567891011ul li a { display: block; color: #00f; padding: 5px;}html.ie ul li a { padding: 6px;}ul li a:hover { color: #f00;} Functions 方法返回值带参数stylus1234567border-radius(val) -webkit-border-radius: val -moz-border-radius: val border-radius: valbutton border-radius(5px); 编译成123456button { -webkit-border-radius: 5px; -moz-border-radius: 5px; border-radius: 5px;}Transparent mixins 不带参数stylus1234567border-radius() -webkit-border-radius: arguments -moz-border-radius: arguments border-radius: argumentsbutton border-radius: 5px 10px; 编译成12345button { -webkit-border-radius: 5px 10px; -moz-border-radius: 5px 10px; border-radius: 5px 10px;} 默认参数不带参数1234567891011stylusadd(a, b = a) a + badd(10, 5)// =&gt; 15add(10)// =&gt; 20函数体 通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。1234567add(a, b = a) a = unit(a, px) b = unit(b, px) a + badd(15%, 10deg)// =&gt; 25 多个返回值通过内置unit()把单位都变成px, 因为赋值在每个参数上，因此，我们可以无视单位换算。12345sizes() 15px 10pxsizes()[0]// =&gt; 15px Variables(变量)常用方法stylus123font-size = 14pxbody font font-size Arial, sans-seri 编译成123body { font: 14px Arial, sans-seri;} 变量放在属性中stylus123456#prompt position: absolute top: 150px left: 50% width: w = 200px margin-left: -(w / 2) 编译成1234567 #prompt { position: absolute; top: 150px; left: 50%; width: 200px; margin-left: -100px;} 块属性访问引用stylus1234#prompt position: absolute width: 200px margin-left: -(@width / 2) 编译成12345 #prompt { position: absolute; width: 200px; margin-left: -100px;} 属性有条件地定义属性stylus:指定z-index值为1，但是，只有在z-index之前未指定的时候才这样：12345678position() position: arguments z-index: 1 unless @z-index #logo z-index: 20 position: absolute #logo2 position: absolute 编译成12345678 #logo { z-index: 20; position: absolute;} #logo2 { position: absolute; z-index: 1;} 向上冒泡stylus:属性会“向上冒泡”查找堆栈直到被发现，或者返回null（如果属性搞不定）下面这个例子，@color被弄成了blue.1234567body color: red ul li color: blue a background-color: @color 编译成123456789body { color: #f00;}body ul li { color: #00f;}body ul li a { background-color: #00f;} Iteration(迭代)stylus1234table for row in 1 2 3 4 5 tr:nth-child({row}) height: 10px * row 编译成123456789101112131415table tr:nth-child(1) { height: 10px;}table tr:nth-child(2) { height: 20px;}table tr:nth-child(3) { height: 30px;}table tr:nth-child(4) { height: 40px;}table tr:nth-child(5) { height: 50px;} Interpolation(插值)stylus123456789vendors = webkit moz o ms officialborder-radius() for vendor in vendors if vendor == official border-radius: arguments else -{vendor}-border-radius: arguments#content border-radius: 5px 编译成1234567#content { -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; -ms-border-radius: 5px; border-radius: 5px;} Operators(运算符)运算符优先级：下表运算符优先级，从最高到最低：123456789101112131415161718. [] ! ~ + - is defined ** * / % + - ... .. &lt;= &gt;= &lt; &gt; in == is != is not isnt is a &amp;&amp; and || or ?: = := ?= += -= *= /= %= not if unless@import@import \"reset.css\" 当使用@import没有.css扩展，会被认为是Stylus片段（如：@import “mixins/border-radius”）。 @import工作原理为：遍历目录队列，并检查任意目录中是否有该文件（类似node的require.paths）。该队列默认为单一路径，从filename选项的dirname衍生而来。 因此，如果你的文件名是/tmp/testing/stylus/main.styl，导入将显现为/tmp/testing/stylus/。 @import也支持索引形式。这意味着当你@import blueprint, 则会理解成blueprint.styl或blueprint/index.styl. 对于库而言，这很有用，既可以展示所有特征与功能，同时又能导入特征子集。 @font-facestylus123456@font-face font-family Geo font-style normal src url(fonts/geo_sans_light/GensansLight.ttf).ingeo font-family Geo 编译成123456789@font-face { font-family: Geo; font-style: normal; src: url(“fonts/geo_sans_light/GensansLight.ttf”); } .ingeo { font-family: Geo; } @media stylus1234@media print #header #footer display none 编译成1234567@media print { #header, #footer { display: none; } } @keyframes stylus1234567@keyframes pulse 0% background-color red transform scale(1.0) rotate(0deg) 33% background-color blue -webkit-transform scale(1.1) rotate(-5deg) 编译成12345678910111213141516171819202122232425262728293031323334353637383940@-moz-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@-webkit-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@-o-keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }}@keyframes pulse { 0% { background-color: #f00; transform: scale(1) rotate(0deg); } 33% { background-color: #00f; -webkit-transform: scale(1.1) rotate(-5deg); }} CSS字面量(CSS Literal)stylus12345@css { body { font: 14px; }} 编译成123body { font: 14px;}","link":"/2018/12/31/简洁清爽的Stylus语法/"},{"title":"面向对象设计原则","text":"一些基本的面向对象设计原则。 面向对象设计原则1. SRP所谓SRP原则，即：Single Responsibility Principle，单一职责原则。原始定义如下： There should never be more than one reason for a class to change.(只有一个引起类改变的原因) 在面向对象编程领域中，单一职责原则（Single responsibility principle）规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。 如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。 单一职责的好处： 类的复杂性降低，实现什么职责都有清晰明确的定义; 可读性提高，复杂性降低，可维护性提高; 变更引起的风险降低。 单一职责原则的注意点： 单一职责最难划分的是职责。 单一职责原则提出标准：用职责和变化原因来衡量接口或类设计的是否优良，但是职责和变化原因都是不可度量的，因项目、环境而异。 接口一定要做到单一职责，类的设计尽量做到只有一个原因引起它变化。 2. LSP所谓LSP原则，即：Liskov Substitution principle，里氏替换原则。原始定义如下： Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象） 更通俗的定义即为：子类可以扩展父类的功能，但不能改变父类原有的功能。里氏替换原则包含了以下4层含义： 子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。 子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。 覆盖或实现父类的方法时输入参数可以被放大。即子类可以覆盖父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。 覆盖或实现父类的方法时输出结果可以被缩小。 优点： 提高代码的重用性，子类拥有父类的方法和属性； 提高代码的可扩展性，子类可形似于父类，但异于父类，保留自我的特性； 缺点： 继承是侵入性的，只要继承就必须拥有父类的所有方法和属性，在一定程度上约束了子类，降低了代码的灵活性； 增加了耦合，当父类的常量、变量或者方法被修改了，需要考虑子类的修改，所以一旦父类有了变动，很可能会造成非常糟糕的结果，要重构大量的代码。 3. ISP所谓ISP原则，即：Interface Segregation Principle，接口隔离原则。原始定义如下： Clients should not be forced to depend upon interfaces that they do not use.(客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。)The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。) 即，接口尽量细化，接口中的方法尽量少。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。 采用接口隔离原则对接口进行约束时，要注意以下几点： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。 4. OCP所谓OCP原则，即：Open Closed Principle，开闭原则。原始定义如下： software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭) 开闭原则（OCP）是面向对象设计中“可复用设计”的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则和设计模式都是实现开闭原则的一种手段。核心就是：对扩展开放，对修改关闭。其含义是说一个软件应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化的。 软件系统中包含的各种组件，例如模块（Module）、类（Class）以及功能（Function）等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的。 实现开闭原则的关键就在于“抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。 开闭原则的好处： 可复用性好; 可维护性好。 5. DIP所谓DIP原则，即：Dependency Inversion Principle，依赖倒置原则。原始定义如下： High-level modules should not depend on low-level modules. Both should depend on abstractions.(高层模块不应该依赖低层模块，两者都应该依赖其抽象) Abstractions should not depend on details. Details should depend on abstractions.(抽象不应该依赖细节；细节应该依赖抽象) 面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。 依赖倒置原则主要有以下三层含义： 高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）； 抽象不应该依赖细节（具体实现）； 细节（具体实现）应该依赖抽象。 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在 Java 中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。依赖倒置原则的核心思想就是面向接口编程。 6. LOD | LKP所谓LOD原则，即：Law of Demeter，迪米特法则，又叫最少知识原则（Least Knowledge Principle，简写LKP），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下： talk only to your immediate friends.(只与直接的朋友通信) 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。 迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友”类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。 7. CRP所谓CRP原则，即：Composite Reuse Principle，组合复用原则。 组合复用原则的核心思想是：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。 继承的缺点主要有以下几点： 继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。 基类的实现发生了改变，派生类的实现也不得不改变。 从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。由于组合可以将已有的对象纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做有下面的好处： 新对象存取组成对象的唯一方法是通过组成对象的getter/setter方法。 组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。 组合复用所需要的依赖较少。 每一个新的类可以将焦点集中到一个任务上。 组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。 组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。 组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 使用继承时必须满足Is-A的关系是才能使用继承，而组合却是一种Has-A的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把Has-A当成了Is-A。","link":"/2019/01/12/面向对象设计原则/"}],"tags":[{"name":"学习计划","slug":"学习计划","link":"/tags/学习计划/"},{"name":"ejs","slug":"ejs","link":"/tags/ejs/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"hackathon","slug":"hackathon","link":"/tags/hackathon/"},{"name":"google","slug":"google","link":"/tags/google/"},{"name":"Front-end","slug":"Front-end","link":"/tags/Front-end/"},{"name":"keyboard accelerators","slug":"keyboard-accelerators","link":"/tags/keyboard-accelerators/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"caffe","slug":"caffe","link":"/tags/caffe/"},{"name":"matlab","slug":"matlab","link":"/tags/matlab/"},{"name":"stylus","slug":"stylus","link":"/tags/stylus/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"面向对象","slug":"面向对象","link":"/tags/面向对象/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"}],"categories":[{"name":"学习计划","slug":"学习计划","link":"/categories/学习计划/"},{"name":"ejs","slug":"ejs","link":"/categories/ejs/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"hachathon","slug":"hachathon","link":"/categories/hachathon/"},{"name":"Front-end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"keyboard accelerators","slug":"keyboard-accelerators","link":"/categories/keyboard-accelerators/"},{"name":"icarus","slug":"icarus","link":"/categories/icarus/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"caffe","slug":"caffe","link":"/categories/caffe/"},{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"}]}